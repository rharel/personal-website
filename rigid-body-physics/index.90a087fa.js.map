{"mappings":"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","sources":["<anon>","projects/rigid-body-physics/demo.ts","projects/rigid-body-physics/rendering.ts","projects/rigid-body-physics/simulation.ts","projects/rigid-body-physics/geometry.ts","projects/rigid-body-physics/collision.ts","projects/rigid-body-physics/quadtree.ts"],"sourcesContent":["function $92df0325268d5d47$var$render_world_frame(world, context, clear_color, entity_styles) {\n    context.save();\n    // Clear canvas.\n    context.fillStyle = clear_color;\n    context.fillRect(0, 0, context.canvas.width, context.canvas.height);\n    // Flip vertical axis.\n    context.translate(0, context.canvas.height);\n    context.scale(1, -1);\n    // Scale to world size.\n    context.scale(context.canvas.width / world.options.size, context.canvas.height / world.options.size);\n    // Draw entities.\n    for(const entity_id in entity_styles){\n        const { fill: fill } = entity_styles[entity_id];\n        const entity = world.entity(parseInt(entity_id));\n        context.beginPath();\n        context.arc(entity.position.x, entity.position.y, entity.radius, 0, 2 * Math.PI);\n        context.fillStyle = fill;\n        context.fill();\n    }\n    context.restore();\n}\nfunction $92df0325268d5d47$export$f4adcd6d36513d43(world, context, clear_color, entity_styles, frame_callback) {\n    // Frame request loop.\n    let frame_request = null;\n    let last_frame_time = null;\n    function on_animation_frame() {\n        const now = performance.now();\n        const real_dt = last_frame_time !== null ? (now - last_frame_time) / 1000 : 1 / 60;\n        last_frame_time = now;\n        world.step(real_dt);\n        $92df0325268d5d47$var$render_world_frame(world, context, clear_color, entity_styles);\n        if (frame_callback) frame_callback();\n        if (frame_request !== null) frame_request = requestAnimationFrame(on_animation_frame);\n    }\n    // Start animation.\n    frame_request = requestAnimationFrame(on_animation_frame);\n    return {\n        pause () {\n            if (frame_request !== null) {\n                cancelAnimationFrame(frame_request);\n                frame_request = null;\n                last_frame_time = null;\n            }\n        },\n        resume () {\n            if (frame_request === null) {\n                last_frame_time = performance.now();\n                frame_request = requestAnimationFrame(on_animation_frame);\n            }\n        }\n    };\n}\n\n\nclass $79bdaf91ddabfb91$export$ac4bca90992eed1 {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n    }\n    clone() {\n        return new $79bdaf91ddabfb91$export$ac4bca90992eed1(this.x, this.y);\n    }\n    assign(other) {\n        this.x = other.x;\n        this.y = other.y;\n        return this;\n    }\n    normalize() {\n        const factor = 1 / this.length();\n        this.x *= factor;\n        this.y *= factor;\n        return this;\n    }\n    set_length(scalar) {\n        const factor = scalar / this.length();\n        this.x *= factor;\n        this.y *= factor;\n        return this;\n    }\n    add(other) {\n        this.x += other.x;\n        this.y += other.y;\n        return this;\n    }\n    subtract(other) {\n        this.x -= other.x;\n        this.y -= other.y;\n        return this;\n    }\n    scale(scalar) {\n        this.x *= scalar;\n        this.y *= scalar;\n        return this;\n    }\n    dot(other) {\n        return this.x * other.x + this.y * other.y;\n    }\n    length_squared() {\n        return this.x * this.x + this.y * this.y;\n    }\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    distance_squared_to(other) {\n        const dx = other.x - this.x;\n        const dy = other.y - this.y;\n        return dx * dx + dy * dy;\n    }\n}\nfunction $79bdaf91ddabfb91$export$aa691064ea72083b(center_1, radius_1, center_2, radius_2) {\n    return center_1.distance_squared_to(center_2) <= (radius_1 + radius_2) * (radius_1 + radius_2);\n}\n\n\n\nclass $b1d81ba20a88f1e6$export$63080c4de6cfc362 {\n    constructor(top, left, width, height){\n        this.top = top;\n        this.left = left;\n        this.width = width;\n        this.height = height;\n        this.bottom = this.top - this.height;\n        this.right = this.left + this.width;\n    }\n    static from_center_and_radius(center_x, center_y, radius) {\n        return new $b1d81ba20a88f1e6$export$63080c4de6cfc362(center_y + radius, center_x - radius, radius, radius);\n    }\n    overlaps(other) {\n        return other.left <= this.right && other.right >= this.left && other.bottom <= this.top && other.top >= this.bottom;\n    }\n}\nclass $b1d81ba20a88f1e6$export$b82688eb02220411 {\n    constructor(depth, bounds){\n        this.depth = depth;\n        this.bounds = bounds;\n        this.node = {\n            kind: \"leaf\",\n            items: []\n        };\n        if (this.depth < 1) throw new Error(\"quadtree node cannot have depth < 1\");\n        else if (this.depth === 1) this.node = {\n            kind: \"leaf\",\n            items: []\n        };\n        else if (this.depth > 1) {\n            const child_depth = depth - 1;\n            const y = this.bounds.top;\n            const x = this.bounds.left;\n            const w2 = 0.5 * this.bounds.width;\n            const h2 = 0.5 * this.bounds.height;\n            this.node = {\n                kind: \"internal\",\n                sw: new $b1d81ba20a88f1e6$export$b82688eb02220411(child_depth, new $b1d81ba20a88f1e6$export$63080c4de6cfc362(y - h2, x, w2, h2)),\n                se: new $b1d81ba20a88f1e6$export$b82688eb02220411(child_depth, new $b1d81ba20a88f1e6$export$63080c4de6cfc362(y - h2, x + w2, w2, h2)),\n                nw: new $b1d81ba20a88f1e6$export$b82688eb02220411(child_depth, new $b1d81ba20a88f1e6$export$63080c4de6cfc362(y, x, w2, h2)),\n                ne: new $b1d81ba20a88f1e6$export$b82688eb02220411(child_depth, new $b1d81ba20a88f1e6$export$63080c4de6cfc362(y, x + w2, w2, h2))\n            };\n        }\n    }\n    nr_items() {\n        if (this.node.kind === \"leaf\") return this.node.items.length;\n        else {\n            let sum = 0;\n            this.for_each_child((child)=>sum += child.nr_items());\n            return sum;\n        }\n    }\n    clear() {\n        if (this.node.kind === \"leaf\") this.node.items.length = 0;\n        else this.for_each_child((child)=>child.clear());\n    }\n    add(entity, target_bounds) {\n        if (!target_bounds.overlaps(this.bounds)) return;\n        else if (this.node.kind === \"internal\") this.for_each_child((child)=>{\n            if (child.bounds.overlaps(target_bounds)) child.add(entity, target_bounds);\n        });\n        else if (!this.node.items.includes(entity)) this.node.items.push(entity);\n    }\n    remove(entity, target_bounds) {\n        if (!target_bounds.overlaps(this.bounds)) return;\n        else if (this.node.kind === \"internal\") this.for_each_child((child)=>{\n            if (child.bounds.overlaps(target_bounds)) child.remove(entity, target_bounds);\n        });\n        else if (this.node.items.includes(entity)) {\n            const index = this.node.items.indexOf(entity);\n            this.node.items.splice(index, 1);\n        }\n    }\n    for_each_child(callback) {\n        if (this.node.kind === \"leaf\") return;\n        callback(this.node.sw);\n        callback(this.node.se);\n        callback(this.node.nw);\n        callback(this.node.ne);\n    }\n    for_each_leaf_with_at_least(threshold, callback) {\n        if (this.nr_items() < threshold) return;\n        else if (this.node.kind === \"leaf\") callback(this.node.items);\n        else this.for_each_child((child)=>child.for_each_leaf_with_at_least(threshold, callback));\n    }\n}\n\n\nclass $296bc57a304a4f5f$export$2e2bcd8739ae039 {\n    constructor(options){\n        this.options = options;\n        this.quadtree = new (0, $b1d81ba20a88f1e6$export$b82688eb02220411)(options.subdivisions, new (0, $b1d81ba20a88f1e6$export$63080c4de6cfc362)(options.bounds_size, 0, options.bounds_size, options.bounds_size));\n    }\n    clear() {\n        this.quadtree.clear();\n    }\n    add(entity) {\n        this.quadtree.add(entity, (0, $b1d81ba20a88f1e6$export$63080c4de6cfc362).from_center_and_radius(entity.position.x, entity.position.y, entity.radius));\n    }\n    remove(entity) {\n        this.quadtree.remove(entity, (0, $b1d81ba20a88f1e6$export$63080c4de6cfc362).from_center_and_radius(entity.position.x, entity.position.y, entity.radius));\n    }\n    moved(entity, old_position) {\n        const old_bounds = (0, $b1d81ba20a88f1e6$export$63080c4de6cfc362).from_center_and_radius(old_position.x, old_position.y, entity.radius);\n        const new_bounds = (0, $b1d81ba20a88f1e6$export$63080c4de6cfc362).from_center_and_radius(entity.position.x, entity.position.y, entity.radius);\n        this.quadtree.remove(entity, old_bounds);\n        this.quadtree.add(entity, new_bounds);\n    }\n    for_each_potential_collision_group(callback) {\n        this.quadtree.for_each_leaf_with_at_least(2, (items)=>{\n            callback(items);\n        });\n    }\n}\n// Finds roots of a quadratic.\nfunction $296bc57a304a4f5f$var$quadratic_solution(a, b, c) {\n    const b2_4ac = b * b - 4 * a * c;\n    if (b2_4ac < 0) return {\n        count: 0\n    };\n    else if (b2_4ac > 0) return {\n        count: 2,\n        x1: (-b + Math.sqrt(b2_4ac)) / (2 * a),\n        x2: (-b - Math.sqrt(b2_4ac)) / (2 * a)\n    };\n    else return {\n        count: 1,\n        x1: -b / (2 * a)\n    };\n}\n// Tests whether two discs with the specified velocities collide in the near future.\n//\n// c1, v1, r1:\n//      The first disc's center, velocity, and radius.\n// c2, v2, r2:\n//      The second disc's center, velocity, and radius.\n//\n// Returns the time of collision or -1 if there is none.\nfunction $296bc57a304a4f5f$var$collision_time(c1, v1, r1, c2, v2, r2) {\n    // The squared distance between the two centers at time t is:\n    //\n    // (1)  D(t) = |(c1 + v1 * t) - (c2 + v2 * t)| ^ 2\n    //\n    // We are interested in finding whether D(t) <= (r1 + r2) ^ 2 on the interval [0, dt].\n    // This is equivalent to solving the following equation:\n    //\n    // (2)   ((c1.x + v1.x * t) - (c2.x + v2.x * t)) ^ 2 +\n    //       ((c1.y + v1.y * t) - (c2.y + v2.y * t)) ^ 2 -\n    //       (r1 + r2) ^ 2 <= 0\n    //\n    // Rewrite:\n    //\n    //      (c1.x - c2.x + (v1.x - v2.x) * t) ^ 2 +\n    //      (c1.y - c2.y + (v1.y - v2.y) * t) ^ 2 -\n    //      (r1 + r2) ^ 2 <= 0\n    //\n    // Denote the components of c1 - c2 = [dc_x, dc_y], those of v1 - v2 [dv_x, dv_y], and call\n    // r1 + r2 = R:\n    //\n    //      (dc_x + dv_x * t) ^ 2 +\n    //      (dc_y + dv_y * t) ^ 2 -\n    //      R ^ 2 <= 0\n    //\n    // Rewrite:\n    //\n    //      dc_x^2 + 2*dc_x*dv_x*t + (dv_x^2)*(t^2) +\n    //      dc_y^2 + 2*dc_y*dv_y*t + (dv_y^2)*(t^2) -\n    //      R ^ 2 <= 0\n    //\n    // Which can be expressed as:\n    //\n    //      a*(t^2) + b*t + c <= 0\n    //\n    // Where:\n    //\n    //      a = dv_x^2 + dv_y^2\n    //      b = 2 * (dc_x*dv_x + dc_y*dv_y)\n    //      c = dc_x^2 + dc_y^2 - R^2\n    //\n    // Solving this yields at most two solutions. All we have to do next is take the minimum\n    // of the two that is also contained within the interval [0, dt].\n    const dv_x = v1.x - v2.x;\n    const dv_y = v1.y - v2.y;\n    const dv_x2 = dv_x * dv_x;\n    const dv_y2 = dv_y * dv_y;\n    const dc_x = c1.x - c2.x;\n    const dc_y = c1.y - c2.y;\n    const dc_x2 = dc_x * dc_x;\n    const dc_y2 = dc_y * dc_y;\n    const solution = $296bc57a304a4f5f$var$quadratic_solution(dv_x2 + dv_y2, 2 * (dc_x * dv_x + dc_y * dv_y), dc_x2 + dc_y2 - (r1 + r2) * (r1 + r2));\n    if (solution.count === 2) {\n        const [t1, t2] = solution.x1 <= solution.x2 ? [\n            solution.x1,\n            solution.x2\n        ] : [\n            solution.x2,\n            solution.x1\n        ];\n        if (t1 < 0 && t2 >= 0) return 0;\n        return t1;\n    } else if (solution.count === 1) return solution.x1;\n    else return -1;\n}\nfunction $296bc57a304a4f5f$export$7f5d6ca1625060a8(entities, time_horizon) {\n    let collisions = [];\n    for(let j = 0; j < entities.length; ++j){\n        const a = entities[j];\n        for(let k = j + 1; k < entities.length; ++k){\n            const b = entities[k];\n            if (a.static && b.static) continue;\n            const t = $296bc57a304a4f5f$var$collision_time(a.position, a.velocity, a.radius, b.position, b.velocity, b.radius);\n            if (0 <= t && t <= time_horizon) collisions.push({\n                entities: [\n                    a,\n                    b\n                ],\n                time: t\n            });\n        }\n    }\n    return collisions;\n}\nfunction $296bc57a304a4f5f$export$fd0a61d200b47931(entities) {\n    const collisions = [];\n    for(let j = 0; j < entities.length; ++j){\n        const a = entities[j];\n        for(let k = j + 1; k < entities.length; ++k){\n            const b = entities[k];\n            if (a.static && b.static) continue;\n            if ((0, $79bdaf91ddabfb91$export$aa691064ea72083b)(a.position, a.radius, b.position, b.radius)) {\n                collisions.push([\n                    a,\n                    b\n                ]);\n                break;\n            }\n        }\n    }\n    return collisions;\n}\nfunction $296bc57a304a4f5f$export$7b62f1d061fe35d9(a, b) {\n    if (a.static && b.static) return;\n    // Ensure static entity is always assigned to a:\n    if (b.static) {\n        const c = a;\n        a = b;\n        b = c;\n    }\n    const dx = a.position.clone().subtract(b.position).set_length(a.radius + b.radius);\n    const du = a.velocity.clone().subtract(b.velocity);\n    const coefficient_of_restitution = 0.5 * (a.elasticity + b.elasticity);\n    const response = coefficient_of_restitution * 2 * du.dot(dx) / ((a.mass + b.mass) * dx.length_squared());\n    if (!a.static) a.velocity.subtract(dx.clone().scale(response * b.mass));\n    if (!b.static) b.velocity.subtract(dx.clone().scale(-response * a.mass));\n}\nfunction $296bc57a304a4f5f$export$9acaec0c61023416(a, b, distance) {\n    if (a.static && b.static) return;\n    const r = a.radius + b.radius + distance;\n    const d2 = a.position.distance_squared_to(b.position);\n    if (d2 >= r * r) return;\n    const collision_axis = a.position.clone().subtract(b.position).normalize();\n    const offset_magnitude = r - Math.sqrt(d2);\n    if (a.static) b.position.add(collision_axis.scale(-offset_magnitude));\n    else if (b.static) a.position.add(collision_axis.scale(offset_magnitude));\n    else {\n        a.position.add(collision_axis.clone().scale(0.5 * offset_magnitude));\n        b.position.add(collision_axis.clone().scale(0.5 * -offset_magnitude));\n    }\n}\n\n\n// Mass of static entities. Should be extremely large.\nconst $12fff36ccf056a0a$var$STATIC_ENTITY_MASS = Math.pow(10, 14);\n// Minimum simulation time increment.\nconst $12fff36ccf056a0a$var$MIN_TIME_STEP_SIZE = 0.001;\n// Minimum distance between entities after collision separation.\nconst $12fff36ccf056a0a$var$MIN_SEPARATION_DISTANCE = 0.001;\n// Objects whose squared velocity is less than this are considered to be at rest.\nconst $12fff36ccf056a0a$var$REST_VELOCITY_THRESHOLD = 0.001;\nfunction $12fff36ccf056a0a$var$step_entity(entity, dt) {\n    const f = entity.applied_force;\n    const m_inv = 1 / entity.mass;\n    const p = entity.position;\n    const v = entity.velocity;\n    const a = 0.5 * dt * m_inv;\n    p.x += dt * (v.x + a * f.x);\n    p.y += dt * (v.y + a * f.y);\n    const b = dt * m_inv;\n    v.x += b * f.x;\n    v.y += b * f.y;\n}\nclass $12fff36ccf056a0a$export$812cd9544993280d {\n    constructor(options){\n        this.options = options;\n        this.next_entity_id = 0;\n        this.entities = new Map();\n        this.collision_culler = new (0, $296bc57a304a4f5f$export$2e2bcd8739ae039)({\n            subdivisions: options.collision_culling_subdivisions,\n            bounds_size: options.size\n        });\n    }\n    clear() {\n        this.collision_culler.clear();\n        this.entities.clear();\n    }\n    spawn(options) {\n        const entity = {\n            mass: options.static ? $12fff36ccf056a0a$var$STATIC_ENTITY_MASS : options.mass !== undefined ? options.mass : 1,\n            radius: options.radius !== undefined ? options.radius : 1,\n            elasticity: options.elasticity !== undefined ? options.elasticity : 0,\n            static: options.static !== undefined ? options.static : false,\n            position: options.position !== undefined ? new (0, $79bdaf91ddabfb91$export$ac4bca90992eed1)(options.position.x, options.position.y) : new (0, $79bdaf91ddabfb91$export$ac4bca90992eed1)(0, 0),\n            velocity: options.velocity !== undefined ? new (0, $79bdaf91ddabfb91$export$ac4bca90992eed1)(options.velocity.x, options.velocity.y) : new (0, $79bdaf91ddabfb91$export$ac4bca90992eed1)(0, 0),\n            applied_force: options.applied_force !== undefined ? new (0, $79bdaf91ddabfb91$export$ac4bca90992eed1)(options.applied_force.x, options.applied_force.y) : new (0, $79bdaf91ddabfb91$export$ac4bca90992eed1)(0, 0)\n        };\n        const id = this.next_entity_id;\n        this.next_entity_id += 1;\n        this.entities.set(id, entity);\n        this.collision_culler.add(entity);\n        return id;\n    }\n    remove(entity_id) {\n        if (!this.entities.has(entity_id)) throw new Error(\"bad entity id\");\n        const entity = this.entities.get(entity_id);\n        this.collision_culler.remove(entity);\n        this.entities.delete(entity_id);\n    }\n    entity(entity_id) {\n        if (!this.entities.has(entity_id)) throw new Error(\"bad entity id\");\n        const entity = this.entities.get(entity_id);\n        return {\n            ...entity,\n            position: {\n                x: entity.position.x,\n                y: entity.position.y\n            },\n            velocity: {\n                x: entity.velocity.x,\n                y: entity.velocity.y\n            },\n            applied_force: {\n                x: entity.applied_force.x,\n                y: entity.applied_force.y\n            }\n        };\n    }\n    update(entity_id, options) {\n        if (!this.entities.has(entity_id)) throw new Error(\"bad entity id\");\n        const entity = this.entities.get(entity_id);\n        const old_position = entity.position.clone();\n        if (options.mass !== undefined) entity.mass = options.mass;\n        if (options.radius !== undefined) entity.radius = options.radius;\n        if (options.elasticity !== undefined) entity.elasticity = options.elasticity;\n        if (options.static !== undefined) {\n            entity.static = options.static;\n            if (entity.static) entity.mass = $12fff36ccf056a0a$var$STATIC_ENTITY_MASS;\n        }\n        if (options.position !== undefined) {\n            entity.position.x = options.position.x;\n            entity.position.y = options.position.y;\n        }\n        if (options.velocity !== undefined) {\n            entity.velocity.x = options.velocity.x;\n            entity.velocity.y = options.velocity.y;\n        }\n        if (options.applied_force !== undefined) {\n            entity.applied_force.x = options.applied_force.x;\n            entity.applied_force.y = options.applied_force.y;\n        }\n        if (options.position !== undefined || options.radius !== undefined) this.collision_culler.moved(entity, old_position);\n    }\n    for_each_entity(callback) {\n        this.entities.forEach((_entity, entity_id)=>{\n            callback(entity_id, this.entity(entity_id));\n        });\n    }\n    step(dt) {\n        if (dt <= 0) throw new Error(\"cannot step with dt <= 0\");\n        this.separate_colliding_entities();\n        if (this.options.high_precision) this.step_with_high_precision(dt);\n        else this.step_with_low_precision(dt);\n        this.entities.forEach((entity)=>{\n            if (entity.velocity.length_squared() < $12fff36ccf056a0a$var$REST_VELOCITY_THRESHOLD) {\n                entity.velocity.x = 0;\n                entity.velocity.y = 0;\n            }\n        });\n    }\n    separate_colliding_entities() {\n        const old_entity_positions = new Map();\n        this.collision_culler.for_each_potential_collision_group((group)=>{\n            // Repeatedly find intersecting pairs, separate them, and check for new intersections.\n            let intersecting_pairs = (0, $296bc57a304a4f5f$export$fd0a61d200b47931)(group);\n            while(intersecting_pairs.length > 0){\n                for (const [entity_1, entity_2] of intersecting_pairs){\n                    if (!entity_1.static) old_entity_positions.set(entity_1, entity_1.position.clone());\n                    if (!entity_2.static) old_entity_positions.set(entity_2, entity_2.position.clone());\n                    (0, $296bc57a304a4f5f$export$9acaec0c61023416)(entity_1, entity_2, $12fff36ccf056a0a$var$MIN_SEPARATION_DISTANCE);\n                    (0, $296bc57a304a4f5f$export$7b62f1d061fe35d9)(entity_1, entity_2);\n                }\n                intersecting_pairs = (0, $296bc57a304a4f5f$export$fd0a61d200b47931)(group);\n            }\n        });\n        old_entity_positions.forEach((old_position, entity)=>{\n            this.collision_culler.moved(entity, old_position);\n        });\n    }\n    step_with_high_precision(dt) {\n        const stepped_entities = new Set();\n        const old_entity_positions = new Map();\n        // Save entity starting positions.\n        this.entities.forEach((entity)=>{\n            old_entity_positions.set(entity, entity.position.clone());\n        });\n        // Handle groups of potentially colliding entities.\n        this.collision_culler.for_each_potential_collision_group((group)=>{\n            for(let i = 0; i < group.length; ++i)stepped_entities.add(group[i]);\n            this.step_entity_group(group, dt);\n        });\n        // Some entities were already stepped forward in time during collision handling,\n        // now we step the rest.\n        this.entities.forEach((entity)=>{\n            if (!stepped_entities.has(entity)) $12fff36ccf056a0a$var$step_entity(entity, dt);\n        });\n        old_entity_positions.forEach((previous_position, entity)=>{\n            this.collision_culler.moved(entity, previous_position);\n        });\n    }\n    step_entity_group(group, dt) {\n        // Step forward in the time interval [now, now + dt] in small increments, ensuring that\n        // collisions are resolved at their precise moment of occurrence.\n        let t = dt;\n        while(t > $12fff36ccf056a0a$var$MIN_TIME_STEP_SIZE){\n            // Find the time of earliest collision.\n            let earliest_collision = null;\n            for (const collision of (0, $296bc57a304a4f5f$export$7f5d6ca1625060a8)(group, t))if (earliest_collision === null || collision.time < earliest_collision.time) earliest_collision = collision;\n            const time_step = earliest_collision !== null ? earliest_collision.time : dt;\n            // Step entire group up to the time of earliest collision.\n            for (const entity of group)$12fff36ccf056a0a$var$step_entity(entity, time_step);\n            // Handle the earliest collision.\n            if (earliest_collision !== null) {\n                (0, $296bc57a304a4f5f$export$7b62f1d061fe35d9)(earliest_collision.entities[0], earliest_collision.entities[1]);\n                (0, $296bc57a304a4f5f$export$9acaec0c61023416)(earliest_collision.entities[0], earliest_collision.entities[1], $12fff36ccf056a0a$var$MIN_SEPARATION_DISTANCE);\n            }\n            // Update remaining time to move forward in time.\n            t -= time_step;\n        }\n    }\n    step_with_low_precision(dt) {\n        this.entities.forEach((entity)=>{\n            if (!entity.static) {\n                const old_position = entity.position.clone();\n                $12fff36ccf056a0a$var$step_entity(entity, dt);\n                this.collision_culler.moved(entity, old_position);\n            }\n        });\n    }\n}\n\n\n\nconst $a75101aa2d33e430$var$WORLD_SIZE = 1;\nconst $a75101aa2d33e430$var$NR_PARTICLES = 50;\nconst $a75101aa2d33e430$var$PARTICLE_ENTITY_RADIUS_MIN = 0.02 * $a75101aa2d33e430$var$WORLD_SIZE * 30 / $a75101aa2d33e430$var$NR_PARTICLES;\nconst $a75101aa2d33e430$var$PARTICLE_ENTITY_RADIUS_MAX = 0.05 * $a75101aa2d33e430$var$WORLD_SIZE * 30 / $a75101aa2d33e430$var$NR_PARTICLES;\nconst $a75101aa2d33e430$var$PARTICLE_VELOCITY_MIN = 0.1 * $a75101aa2d33e430$var$WORLD_SIZE;\nconst $a75101aa2d33e430$var$PARTICLE_VELOCITY_MAX = 0.5 * $a75101aa2d33e430$var$WORLD_SIZE;\nconst $a75101aa2d33e430$var$PARTICLE_ELASTICITY = 0.95;\nconst $a75101aa2d33e430$var$PALETTE = [\n    \"red\",\n    \"blue\",\n    \"brown\",\n    \"green\",\n    \"orange\",\n    \"magenta\",\n    \"purple\"\n];\nfunction $a75101aa2d33e430$var$random_in_range(lower, upper) {\n    return lower + Math.random() * (upper - lower);\n}\nfunction $a75101aa2d33e430$var$setup() {\n    const entity_styles = {};\n    const world = new (0, $12fff36ccf056a0a$export$812cd9544993280d)({\n        size: $a75101aa2d33e430$var$WORLD_SIZE,\n        collision_culling_subdivisions: 3,\n        high_precision: true\n    });\n    for(let i = 0; i < $a75101aa2d33e430$var$NR_PARTICLES; ++i){\n        const radius = $a75101aa2d33e430$var$random_in_range($a75101aa2d33e430$var$PARTICLE_ENTITY_RADIUS_MIN, $a75101aa2d33e430$var$PARTICLE_ENTITY_RADIUS_MAX);\n        const mass = Math.PI * radius * radius;\n        const particle_id = world.spawn({\n            mass: mass,\n            radius: radius,\n            elasticity: $a75101aa2d33e430$var$PARTICLE_ELASTICITY,\n            position: {\n                x: $a75101aa2d33e430$var$random_in_range(radius, world.options.size - radius),\n                y: $a75101aa2d33e430$var$random_in_range(radius, world.options.size - radius)\n            },\n            velocity: new (0, $79bdaf91ddabfb91$export$ac4bca90992eed1)($a75101aa2d33e430$var$random_in_range(-1, 1), $a75101aa2d33e430$var$random_in_range(-1, 1)).set_length($a75101aa2d33e430$var$random_in_range($a75101aa2d33e430$var$PARTICLE_VELOCITY_MIN, $a75101aa2d33e430$var$PARTICLE_VELOCITY_MAX))\n        });\n        entity_styles[particle_id] = {\n            fill: $a75101aa2d33e430$var$PALETTE[i % $a75101aa2d33e430$var$PALETTE.length]\n        };\n    }\n    const canvas_elements = document.getElementsByClassName(\"demo-canvas\");\n    if (canvas_elements.length !== 1) throw new Error(`expected 1 demo canvas, found ${canvas_elements.length}`);\n    const canvas = canvas_elements.item(0);\n    if (!(canvas instanceof HTMLCanvasElement)) throw new Error(`expected canvas element, found ${typeof canvas}`);\n    const context = canvas.getContext(\"2d\", {\n        alpha: false\n    });\n    if (context === null) throw new Error(\"cannot get rendering context\");\n    const controls = (0, $92df0325268d5d47$export$f4adcd6d36513d43)(world, context, \"white\", entity_styles, ()=>{\n        let total_velocity = 0;\n        world.for_each_entity((entity_id, entity)=>{\n            let update_required = false;\n            if (entity.position.x < entity.radius) {\n                entity.position.x = entity.radius;\n                entity.velocity.x *= -1;\n                update_required = true;\n            }\n            if (entity.position.x > world.options.size - entity.radius) {\n                entity.position.x = world.options.size - entity.radius;\n                entity.velocity.x *= -1;\n                update_required = true;\n            }\n            if (entity.position.y < entity.radius) {\n                entity.position.y = entity.radius;\n                entity.velocity.y *= -1;\n                update_required = true;\n            }\n            if (entity.position.y > world.options.size - entity.radius) {\n                entity.position.y = world.options.size - entity.radius;\n                entity.velocity.y *= -1;\n                update_required = true;\n            }\n            if (update_required) world.update(entity_id, {\n                position: entity.position,\n                velocity: entity.velocity\n            });\n            total_velocity += entity.velocity.x + entity.velocity.y;\n        });\n        if (total_velocity === 0) controls.pause();\n    });\n}\nwindow.addEventListener(\"DOMContentLoaded\", $a75101aa2d33e430$var$setup);\n\n\n//# sourceMappingURL=index.90a087fa.js.map\n","import { EntityStyles, render_world_animation } from \"./rendering\";\r\nimport { World } from \"./simulation\";\r\nimport { Vec2 } from \"./geometry\";\r\n\r\nconst WORLD_SIZE = 1;\r\nconst NR_PARTICLES = 50;\r\nconst PARTICLE_ENTITY_RADIUS_MIN = (0.02 * WORLD_SIZE * 30) / NR_PARTICLES;\r\nconst PARTICLE_ENTITY_RADIUS_MAX = (0.05 * WORLD_SIZE * 30) / NR_PARTICLES;\r\nconst PARTICLE_VELOCITY_MIN = 0.1 * WORLD_SIZE;\r\nconst PARTICLE_VELOCITY_MAX = 0.5 * WORLD_SIZE;\r\nconst PARTICLE_ELASTICITY = 0.95;\r\nconst PALETTE = [\r\n  \"red\",\r\n  \"blue\",\r\n  \"brown\",\r\n  \"green\",\r\n  \"orange\",\r\n  \"magenta\",\r\n  \"purple\",\r\n];\r\n\r\nfunction random_in_range(lower: number, upper: number): number {\r\n  return lower + Math.random() * (upper - lower);\r\n}\r\n\r\nfunction setup() {\r\n  const entity_styles: EntityStyles = {};\r\n\r\n  const world = new World({\r\n    size: WORLD_SIZE,\r\n    collision_culling_subdivisions: 3,\r\n    high_precision: true,\r\n  });\r\n\r\n  for (let i = 0; i < NR_PARTICLES; ++i) {\r\n    const radius = random_in_range(\r\n      PARTICLE_ENTITY_RADIUS_MIN,\r\n      PARTICLE_ENTITY_RADIUS_MAX\r\n    );\r\n    const mass = Math.PI * radius * radius;\r\n    const particle_id = world.spawn({\r\n      mass,\r\n      radius,\r\n      elasticity: PARTICLE_ELASTICITY,\r\n      position: {\r\n        x: random_in_range(radius, world.options.size - radius),\r\n        y: random_in_range(radius, world.options.size - radius),\r\n      },\r\n      velocity: new Vec2(\r\n        random_in_range(-1, 1),\r\n        random_in_range(-1, 1)\r\n      ).set_length(\r\n        random_in_range(PARTICLE_VELOCITY_MIN, PARTICLE_VELOCITY_MAX)\r\n      ),\r\n    });\r\n    entity_styles[particle_id] = { fill: PALETTE[i % PALETTE.length] };\r\n  }\r\n\r\n  const canvas_elements = document.getElementsByClassName(\"demo-canvas\");\r\n  if (canvas_elements.length !== 1) {\r\n    throw new Error(`expected 1 demo canvas, found ${canvas_elements.length}`);\r\n  }\r\n\r\n  const canvas = canvas_elements.item(0);\r\n  if (!(canvas instanceof HTMLCanvasElement)) {\r\n    throw new Error(`expected canvas element, found ${typeof canvas}`);\r\n  }\r\n\r\n  const context = canvas.getContext(\"2d\", { alpha: false });\r\n  if (context === null) {\r\n    throw new Error(\"cannot get rendering context\");\r\n  }\r\n\r\n  const controls = render_world_animation(\r\n    world,\r\n    context,\r\n    \"white\",\r\n    entity_styles,\r\n    () => {\r\n      let total_velocity = 0;\r\n      world.for_each_entity((entity_id, entity) => {\r\n        let update_required = false;\r\n        if (entity.position.x < entity.radius) {\r\n          entity.position.x = entity.radius;\r\n          entity.velocity.x *= -1;\r\n          update_required = true;\r\n        }\r\n        if (entity.position.x > world.options.size - entity.radius) {\r\n          entity.position.x = world.options.size - entity.radius;\r\n          entity.velocity.x *= -1;\r\n          update_required = true;\r\n        }\r\n        if (entity.position.y < entity.radius) {\r\n          entity.position.y = entity.radius;\r\n          entity.velocity.y *= -1;\r\n          update_required = true;\r\n        }\r\n        if (entity.position.y > world.options.size - entity.radius) {\r\n          entity.position.y = world.options.size - entity.radius;\r\n          entity.velocity.y *= -1;\r\n          update_required = true;\r\n        }\r\n        if (update_required) {\r\n          world.update(entity_id, {\r\n            position: entity.position,\r\n            velocity: entity.velocity,\r\n          });\r\n        }\r\n        total_velocity += entity.velocity.x + entity.velocity.y;\r\n      });\r\n      if (total_velocity === 0) {\r\n        controls.pause();\r\n      }\r\n    }\r\n  );\r\n}\r\n\r\nwindow.addEventListener(\"DOMContentLoaded\", setup);\r\n","import { World } from \"./simulation\";\r\n\r\nexport type EntityStyles = {\r\n  [key: number]: { fill: string };\r\n};\r\n\r\nexport type AnimationControls = {\r\n  pause(): void;\r\n  resume(): void;\r\n};\r\n\r\nfunction render_world_frame(\r\n  world: World,\r\n  context: CanvasRenderingContext2D,\r\n  clear_color: string,\r\n  entity_styles: EntityStyles\r\n) {\r\n  context.save();\r\n\r\n  // Clear canvas.\r\n  context.fillStyle = clear_color;\r\n  context.fillRect(0, 0, context.canvas.width, context.canvas.height);\r\n\r\n  // Flip vertical axis.\r\n  context.translate(0, context.canvas.height);\r\n  context.scale(1, -1);\r\n\r\n  // Scale to world size.\r\n  context.scale(\r\n    context.canvas.width / world.options.size,\r\n    context.canvas.height / world.options.size\r\n  );\r\n\r\n  // Draw entities.\r\n  for (const entity_id in entity_styles) {\r\n    const { fill } = entity_styles[entity_id];\r\n    const entity = world.entity(parseInt(entity_id));\r\n    context.beginPath();\r\n    context.arc(\r\n      entity.position.x,\r\n      entity.position.y,\r\n      entity.radius,\r\n      0,\r\n      2 * Math.PI\r\n    );\r\n    context.fillStyle = fill;\r\n    context.fill();\r\n  }\r\n\r\n  context.restore();\r\n}\r\n\r\nexport function render_world_animation(\r\n  world: World,\r\n  context: CanvasRenderingContext2D,\r\n  clear_color: string,\r\n  entity_styles: EntityStyles,\r\n  frame_callback?: () => void\r\n): AnimationControls {\r\n  // Frame request loop.\r\n  let frame_request: number | null = null;\r\n  let last_frame_time: number | null = null;\r\n  function on_animation_frame() {\r\n    const now = performance.now();\r\n    const real_dt =\r\n      last_frame_time !== null ? (now - last_frame_time) / 1000 : 1 / 60;\r\n    last_frame_time = now;\r\n    world.step(real_dt);\r\n    render_world_frame(\r\n      world,\r\n      context as CanvasRenderingContext2D,\r\n      clear_color,\r\n      entity_styles\r\n    );\r\n    if (frame_callback) {\r\n      frame_callback();\r\n    }\r\n    if (frame_request !== null) {\r\n      frame_request = requestAnimationFrame(on_animation_frame);\r\n    }\r\n  }\r\n\r\n  // Start animation.\r\n  frame_request = requestAnimationFrame(on_animation_frame);\r\n\r\n  return {\r\n    pause() {\r\n      if (frame_request !== null) {\r\n        cancelAnimationFrame(frame_request);\r\n        frame_request = null;\r\n        last_frame_time = null;\r\n      }\r\n    },\r\n    resume() {\r\n      if (frame_request === null) {\r\n        last_frame_time = performance.now();\r\n        frame_request = requestAnimationFrame(on_animation_frame);\r\n      }\r\n    },\r\n  };\r\n}\r\n","import { Vec2 } from \"./geometry\";\r\nimport CollisionCuller, {\r\n  future_collisions,\r\n  present_collisions,\r\n  separate_entities,\r\n  collide_entities,\r\n  Collision,\r\n} from \"./collision\";\r\n\r\n// Mass of static entities. Should be extremely large.\r\nconst STATIC_ENTITY_MASS = Math.pow(10, 14);\r\n\r\n// Minimum simulation time increment.\r\nconst MIN_TIME_STEP_SIZE = 0.001;\r\n\r\n// Minimum distance between entities after collision separation.\r\nconst MIN_SEPARATION_DISTANCE = 0.001;\r\n\r\n// Objects whose squared velocity is less than this are considered to be at rest.\r\nconst REST_VELOCITY_THRESHOLD = 0.001;\r\n\r\nexport type Entity = {\r\n  mass: number;\r\n  radius: number;\r\n  elasticity: number;\r\n  static: boolean;\r\n  position: Vec2;\r\n  velocity: Vec2;\r\n  applied_force: Vec2;\r\n};\r\n\r\nexport type EntityView = {\r\n  mass: number;\r\n  radius: number;\r\n  elasticity: number;\r\n  static: boolean;\r\n  position: { x: number; y: number };\r\n  velocity: { x: number; y: number };\r\n  applied_force: { x: number; y: number };\r\n};\r\n\r\nexport type EntityOptions = {\r\n  [key in keyof EntityView]?: EntityView[key];\r\n};\r\n\r\nfunction step_entity(entity: Entity, dt: number) {\r\n  const f = entity.applied_force;\r\n  const m_inv = 1 / entity.mass;\r\n  const p = entity.position;\r\n  const v = entity.velocity;\r\n\r\n  const a = 0.5 * dt * m_inv;\r\n  p.x += dt * (v.x + a * f.x);\r\n  p.y += dt * (v.y + a * f.y);\r\n\r\n  const b = dt * m_inv;\r\n  v.x += b * f.x;\r\n  v.y += b * f.y;\r\n}\r\n\r\nexport type WorldOptions = {\r\n  size: number;\r\n  collision_culling_subdivisions: number;\r\n  high_precision: boolean;\r\n};\r\n\r\nexport class World {\r\n  constructor(readonly options: WorldOptions) {\r\n    this.collision_culler = new CollisionCuller({\r\n      subdivisions: options.collision_culling_subdivisions,\r\n      bounds_size: options.size,\r\n    });\r\n  }\r\n\r\n  clear() {\r\n    this.collision_culler.clear();\r\n    this.entities.clear();\r\n  }\r\n\r\n  spawn(options: EntityOptions): number {\r\n    const entity = {\r\n      mass: options.static\r\n        ? STATIC_ENTITY_MASS\r\n        : options.mass !== undefined\r\n        ? options.mass\r\n        : 1,\r\n      radius: options.radius !== undefined ? options.radius : 1,\r\n      elasticity: options.elasticity !== undefined ? options.elasticity : 0,\r\n      static: options.static !== undefined ? options.static : false,\r\n      position:\r\n        options.position !== undefined\r\n          ? new Vec2(options.position.x, options.position.y)\r\n          : new Vec2(0, 0),\r\n      velocity:\r\n        options.velocity !== undefined\r\n          ? new Vec2(options.velocity.x, options.velocity.y)\r\n          : new Vec2(0, 0),\r\n      applied_force:\r\n        options.applied_force !== undefined\r\n          ? new Vec2(options.applied_force.x, options.applied_force.y)\r\n          : new Vec2(0, 0),\r\n    };\r\n\r\n    const id = this.next_entity_id;\r\n    this.next_entity_id += 1;\r\n\r\n    this.entities.set(id, entity);\r\n    this.collision_culler.add(entity);\r\n\r\n    return id;\r\n  }\r\n\r\n  remove(entity_id: number) {\r\n    if (!this.entities.has(entity_id)) {\r\n      throw new Error(\"bad entity id\");\r\n    }\r\n    const entity = this.entities.get(entity_id) as Entity;\r\n    this.collision_culler.remove(entity);\r\n    this.entities.delete(entity_id);\r\n  }\r\n\r\n  entity(entity_id: number): EntityView {\r\n    if (!this.entities.has(entity_id)) {\r\n      throw new Error(\"bad entity id\");\r\n    }\r\n    const entity = this.entities.get(entity_id) as Entity;\r\n    return {\r\n      ...entity,\r\n      position: { x: entity.position.x, y: entity.position.y },\r\n      velocity: { x: entity.velocity.x, y: entity.velocity.y },\r\n      applied_force: { x: entity.applied_force.x, y: entity.applied_force.y },\r\n    };\r\n  }\r\n\r\n  update(entity_id: number, options: EntityOptions) {\r\n    if (!this.entities.has(entity_id)) {\r\n      throw new Error(\"bad entity id\");\r\n    }\r\n\r\n    const entity = this.entities.get(entity_id) as Entity;\r\n    const old_position = entity.position.clone();\r\n\r\n    if (options.mass !== undefined) {\r\n      entity.mass = options.mass;\r\n    }\r\n    if (options.radius !== undefined) {\r\n      entity.radius = options.radius;\r\n    }\r\n    if (options.elasticity !== undefined) {\r\n      entity.elasticity = options.elasticity;\r\n    }\r\n    if (options.static !== undefined) {\r\n      entity.static = options.static;\r\n      if (entity.static) {\r\n        entity.mass = STATIC_ENTITY_MASS;\r\n      }\r\n    }\r\n    if (options.position !== undefined) {\r\n      entity.position.x = options.position.x;\r\n      entity.position.y = options.position.y;\r\n    }\r\n    if (options.velocity !== undefined) {\r\n      entity.velocity.x = options.velocity.x;\r\n      entity.velocity.y = options.velocity.y;\r\n    }\r\n    if (options.applied_force !== undefined) {\r\n      entity.applied_force.x = options.applied_force.x;\r\n      entity.applied_force.y = options.applied_force.y;\r\n    }\r\n\r\n    if (options.position !== undefined || options.radius !== undefined) {\r\n      this.collision_culler.moved(entity, old_position);\r\n    }\r\n  }\r\n\r\n  for_each_entity(callback: (id: number, entity: EntityView) => void) {\r\n    this.entities.forEach((_entity, entity_id) => {\r\n      callback(entity_id, this.entity(entity_id));\r\n    });\r\n  }\r\n\r\n  step(dt: number) {\r\n    if (dt <= 0) {\r\n      throw new Error(\"cannot step with dt <= 0\");\r\n    }\r\n\r\n    this.separate_colliding_entities();\r\n\r\n    if (this.options.high_precision) {\r\n      this.step_with_high_precision(dt);\r\n    } else {\r\n      this.step_with_low_precision(dt);\r\n    }\r\n\r\n    this.entities.forEach((entity) => {\r\n      if (entity.velocity.length_squared() < REST_VELOCITY_THRESHOLD) {\r\n        entity.velocity.x = 0;\r\n        entity.velocity.y = 0;\r\n      }\r\n    });\r\n  }\r\n\r\n  private separate_colliding_entities() {\r\n    const old_entity_positions = new Map<Entity, Vec2>();\r\n\r\n    this.collision_culler.for_each_potential_collision_group((group) => {\r\n      // Repeatedly find intersecting pairs, separate them, and check for new intersections.\r\n      let intersecting_pairs = present_collisions(group);\r\n      while (intersecting_pairs.length > 0) {\r\n        for (const [entity_1, entity_2] of intersecting_pairs) {\r\n          if (!entity_1.static) {\r\n            old_entity_positions.set(entity_1, entity_1.position.clone());\r\n          }\r\n          if (!entity_2.static) {\r\n            old_entity_positions.set(entity_2, entity_2.position.clone());\r\n          }\r\n          separate_entities(entity_1, entity_2, MIN_SEPARATION_DISTANCE);\r\n          collide_entities(entity_1, entity_2);\r\n        }\r\n        intersecting_pairs = present_collisions(group);\r\n      }\r\n    });\r\n\r\n    old_entity_positions.forEach((old_position, entity) => {\r\n      this.collision_culler.moved(entity, old_position);\r\n    });\r\n  }\r\n\r\n  private step_with_high_precision(dt: number) {\r\n    const stepped_entities = new Set<Entity>();\r\n    const old_entity_positions = new Map<Entity, Vec2>();\r\n\r\n    // Save entity starting positions.\r\n    this.entities.forEach((entity) => {\r\n      old_entity_positions.set(entity, entity.position.clone());\r\n    });\r\n\r\n    // Handle groups of potentially colliding entities.\r\n    this.collision_culler.for_each_potential_collision_group((group) => {\r\n      for (let i = 0; i < group.length; ++i) {\r\n        stepped_entities.add(group[i]);\r\n      }\r\n      this.step_entity_group(group, dt);\r\n    });\r\n\r\n    // Some entities were already stepped forward in time during collision handling,\r\n    // now we step the rest.\r\n    this.entities.forEach((entity) => {\r\n      if (!stepped_entities.has(entity)) {\r\n        step_entity(entity, dt);\r\n      }\r\n    });\r\n\r\n    old_entity_positions.forEach((previous_position, entity) => {\r\n      this.collision_culler.moved(entity, previous_position);\r\n    });\r\n  }\r\n\r\n  private step_entity_group(group: Entity[], dt: number) {\r\n    // Step forward in the time interval [now, now + dt] in small increments, ensuring that\r\n    // collisions are resolved at their precise moment of occurrence.\r\n    let t = dt;\r\n    while (t > MIN_TIME_STEP_SIZE) {\r\n      // Find the time of earliest collision.\r\n      let earliest_collision: Collision | null = null;\r\n      for (const collision of future_collisions(group, t)) {\r\n        if (\r\n          earliest_collision === null ||\r\n          collision.time < earliest_collision.time\r\n        ) {\r\n          earliest_collision = collision;\r\n        }\r\n      }\r\n\r\n      const time_step =\r\n        earliest_collision !== null ? earliest_collision.time : dt;\r\n\r\n      // Step entire group up to the time of earliest collision.\r\n      for (const entity of group) {\r\n        step_entity(entity, time_step);\r\n      }\r\n\r\n      // Handle the earliest collision.\r\n      if (earliest_collision !== null) {\r\n        collide_entities(\r\n          earliest_collision.entities[0],\r\n          earliest_collision.entities[1]\r\n        );\r\n        separate_entities(\r\n          earliest_collision.entities[0],\r\n          earliest_collision.entities[1],\r\n          MIN_SEPARATION_DISTANCE\r\n        );\r\n      }\r\n\r\n      // Update remaining time to move forward in time.\r\n      t -= time_step;\r\n    }\r\n  }\r\n\r\n  private step_with_low_precision(dt: number) {\r\n    this.entities.forEach((entity) => {\r\n      if (!entity.static) {\r\n        const old_position = entity.position.clone();\r\n        step_entity(entity, dt);\r\n        this.collision_culler.moved(entity, old_position);\r\n      }\r\n    });\r\n  }\r\n\r\n  private next_entity_id = 0;\r\n  private readonly collision_culler: CollisionCuller;\r\n  private readonly entities = new Map<number, Entity>();\r\n}\r\n","export class Vec2 {\r\n  constructor(public x: number, public y: number) {}\r\n\r\n  clone(): Vec2 {\r\n    return new Vec2(this.x, this.y);\r\n  }\r\n\r\n  assign(other: Vec2): Vec2 {\r\n    this.x = other.x;\r\n    this.y = other.y;\r\n    return this;\r\n  }\r\n\r\n  normalize(): Vec2 {\r\n    const factor = 1 / this.length();\r\n    this.x *= factor;\r\n    this.y *= factor;\r\n    return this;\r\n  }\r\n\r\n  set_length(scalar: number): Vec2 {\r\n    const factor = scalar / this.length();\r\n    this.x *= factor;\r\n    this.y *= factor;\r\n    return this;\r\n  }\r\n\r\n  add(other: Vec2): Vec2 {\r\n    this.x += other.x;\r\n    this.y += other.y;\r\n    return this;\r\n  }\r\n\r\n  subtract(other: Vec2): Vec2 {\r\n    this.x -= other.x;\r\n    this.y -= other.y;\r\n    return this;\r\n  }\r\n\r\n  scale(scalar: number): Vec2 {\r\n    this.x *= scalar;\r\n    this.y *= scalar;\r\n    return this;\r\n  }\r\n\r\n  dot(other: Vec2): number {\r\n    return this.x * other.x + this.y * other.y;\r\n  }\r\n\r\n  length_squared(): number {\r\n    return this.x * this.x + this.y * this.y;\r\n  }\r\n\r\n  length(): number {\r\n    return Math.sqrt(this.x * this.x + this.y * this.y);\r\n  }\r\n\r\n  distance_squared_to(other: Vec2): number {\r\n    const dx = other.x - this.x;\r\n    const dy = other.y - this.y;\r\n    return dx * dx + dy * dy;\r\n  }\r\n}\r\n\r\nexport function discs_intersect(\r\n  center_1: Vec2,\r\n  radius_1: number,\r\n  center_2: Vec2,\r\n  radius_2: number\r\n): boolean {\r\n  return (\r\n    center_1.distance_squared_to(center_2) <=\r\n    (radius_1 + radius_2) * (radius_1 + radius_2)\r\n  );\r\n}\r\n","import { discs_intersect, Vec2 } from \"./geometry\";\r\nimport { Entity } from \"./simulation\";\r\nimport { BoundingBox, QuadTree } from \"./quadtree\";\r\n\r\nexport type CullingOptions = {\r\n  bounds_size: number;\r\n  subdivisions: number;\r\n};\r\n\r\nexport default class CollisionCuller {\r\n  constructor(readonly options: CullingOptions) {\r\n    this.quadtree = new QuadTree(\r\n      options.subdivisions,\r\n      new BoundingBox(\r\n        options.bounds_size,\r\n        0,\r\n        options.bounds_size,\r\n        options.bounds_size\r\n      )\r\n    );\r\n  }\r\n\r\n  clear() {\r\n    this.quadtree.clear();\r\n  }\r\n\r\n  add(entity: Entity) {\r\n    this.quadtree.add(\r\n      entity,\r\n      BoundingBox.from_center_and_radius(\r\n        entity.position.x,\r\n        entity.position.y,\r\n        entity.radius\r\n      )\r\n    );\r\n  }\r\n\r\n  remove(entity: Entity) {\r\n    this.quadtree.remove(\r\n      entity,\r\n      BoundingBox.from_center_and_radius(\r\n        entity.position.x,\r\n        entity.position.y,\r\n        entity.radius\r\n      )\r\n    );\r\n  }\r\n\r\n  moved(entity: Entity, old_position: Vec2) {\r\n    const old_bounds = BoundingBox.from_center_and_radius(\r\n      old_position.x,\r\n      old_position.y,\r\n      entity.radius\r\n    );\r\n    const new_bounds = BoundingBox.from_center_and_radius(\r\n      entity.position.x,\r\n      entity.position.y,\r\n      entity.radius\r\n    );\r\n    this.quadtree.remove(entity, old_bounds);\r\n    this.quadtree.add(entity, new_bounds);\r\n  }\r\n\r\n  for_each_potential_collision_group(callback: (group: Array<Entity>) => void) {\r\n    this.quadtree.for_each_leaf_with_at_least(2, (items) => {\r\n      callback(items);\r\n    });\r\n  }\r\n\r\n  private readonly quadtree: QuadTree<Entity>;\r\n}\r\n\r\n// Finds roots of a quadratic.\r\nfunction quadratic_solution(\r\n  a: number,\r\n  b: number,\r\n  c: number\r\n):\r\n  | { count: 2; x1: number; x2: number }\r\n  | { count: 1; x1: number }\r\n  | { count: 0 } {\r\n  const b2_4ac = b * b - 4 * a * c;\r\n  if (b2_4ac < 0) {\r\n    return { count: 0 };\r\n  } else if (b2_4ac > 0) {\r\n    return {\r\n      count: 2,\r\n      x1: (-b + Math.sqrt(b2_4ac)) / (2 * a),\r\n      x2: (-b - Math.sqrt(b2_4ac)) / (2 * a),\r\n    };\r\n  } else {\r\n    return { count: 1, x1: -b / (2 * a) };\r\n  }\r\n}\r\n\r\n// Tests whether two discs with the specified velocities collide in the near future.\r\n//\r\n// c1, v1, r1:\r\n//      The first disc's center, velocity, and radius.\r\n// c2, v2, r2:\r\n//      The second disc's center, velocity, and radius.\r\n//\r\n// Returns the time of collision or -1 if there is none.\r\nfunction collision_time(\r\n  c1: Vec2,\r\n  v1: Vec2,\r\n  r1: number,\r\n  c2: Vec2,\r\n  v2: Vec2,\r\n  r2: number\r\n): number {\r\n  // The squared distance between the two centers at time t is:\r\n  //\r\n  // (1)  D(t) = |(c1 + v1 * t) - (c2 + v2 * t)| ^ 2\r\n  //\r\n  // We are interested in finding whether D(t) <= (r1 + r2) ^ 2 on the interval [0, dt].\r\n  // This is equivalent to solving the following equation:\r\n  //\r\n  // (2)   ((c1.x + v1.x * t) - (c2.x + v2.x * t)) ^ 2 +\r\n  //       ((c1.y + v1.y * t) - (c2.y + v2.y * t)) ^ 2 -\r\n  //       (r1 + r2) ^ 2 <= 0\r\n  //\r\n  // Rewrite:\r\n  //\r\n  //      (c1.x - c2.x + (v1.x - v2.x) * t) ^ 2 +\r\n  //      (c1.y - c2.y + (v1.y - v2.y) * t) ^ 2 -\r\n  //      (r1 + r2) ^ 2 <= 0\r\n  //\r\n  // Denote the components of c1 - c2 = [dc_x, dc_y], those of v1 - v2 [dv_x, dv_y], and call\r\n  // r1 + r2 = R:\r\n  //\r\n  //      (dc_x + dv_x * t) ^ 2 +\r\n  //      (dc_y + dv_y * t) ^ 2 -\r\n  //      R ^ 2 <= 0\r\n  //\r\n  // Rewrite:\r\n  //\r\n  //      dc_x^2 + 2*dc_x*dv_x*t + (dv_x^2)*(t^2) +\r\n  //      dc_y^2 + 2*dc_y*dv_y*t + (dv_y^2)*(t^2) -\r\n  //      R ^ 2 <= 0\r\n  //\r\n  // Which can be expressed as:\r\n  //\r\n  //      a*(t^2) + b*t + c <= 0\r\n  //\r\n  // Where:\r\n  //\r\n  //      a = dv_x^2 + dv_y^2\r\n  //      b = 2 * (dc_x*dv_x + dc_y*dv_y)\r\n  //      c = dc_x^2 + dc_y^2 - R^2\r\n  //\r\n  // Solving this yields at most two solutions. All we have to do next is take the minimum\r\n  // of the two that is also contained within the interval [0, dt].\r\n\r\n  const dv_x = v1.x - v2.x;\r\n  const dv_y = v1.y - v2.y;\r\n\r\n  const dv_x2 = dv_x * dv_x;\r\n  const dv_y2 = dv_y * dv_y;\r\n\r\n  const dc_x = c1.x - c2.x;\r\n  const dc_y = c1.y - c2.y;\r\n\r\n  const dc_x2 = dc_x * dc_x;\r\n  const dc_y2 = dc_y * dc_y;\r\n\r\n  const solution = quadratic_solution(\r\n    dv_x2 + dv_y2,\r\n    2 * (dc_x * dv_x + dc_y * dv_y),\r\n    dc_x2 + dc_y2 - (r1 + r2) * (r1 + r2)\r\n  );\r\n\r\n  if (solution.count === 2) {\r\n    const [t1, t2] =\r\n      solution.x1 <= solution.x2\r\n        ? [solution.x1, solution.x2]\r\n        : [solution.x2, solution.x1];\r\n    if (t1 < 0 && t2 >= 0) {\r\n      return 0;\r\n    }\r\n    return t1;\r\n  } else if (solution.count === 1) {\r\n    return solution.x1;\r\n  } else {\r\n    return -1;\r\n  }\r\n}\r\n\r\nexport type Collision = {\r\n  entities: [Entity, Entity];\r\n  time: number;\r\n};\r\n\r\n// Finds near-future colliding pairs.\r\nexport function future_collisions(\r\n  entities: Entity[],\r\n  time_horizon: number\r\n): Collision[] {\r\n  let collisions: Collision[] = [];\r\n  for (let j = 0; j < entities.length; ++j) {\r\n    const a = entities[j];\r\n    for (let k = j + 1; k < entities.length; ++k) {\r\n      const b = entities[k];\r\n\r\n      if (a.static && b.static) {\r\n        continue;\r\n      }\r\n\r\n      const t = collision_time(\r\n        a.position,\r\n        a.velocity,\r\n        a.radius,\r\n        b.position,\r\n        b.velocity,\r\n        b.radius\r\n      );\r\n\r\n      if (0 <= t && t <= time_horizon) {\r\n        collisions.push({\r\n          entities: [a, b],\r\n          time: t,\r\n        });\r\n      }\r\n    }\r\n  }\r\n  return collisions;\r\n}\r\n\r\n// Finds colliding pairs.\r\nexport function present_collisions(entities: Entity[]): [Entity, Entity][] {\r\n  const collisions: [Entity, Entity][] = [];\r\n  for (let j = 0; j < entities.length; ++j) {\r\n    const a = entities[j];\r\n    for (let k = j + 1; k < entities.length; ++k) {\r\n      const b = entities[k];\r\n\r\n      if (a.static && b.static) {\r\n        continue;\r\n      }\r\n\r\n      if (discs_intersect(a.position, a.radius, b.position, b.radius)) {\r\n        collisions.push([a, b]);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  return collisions;\r\n}\r\n\r\n// Applies collision response.\r\nexport function collide_entities(a: Entity, b: Entity) {\r\n  if (a.static && b.static) {\r\n    return;\r\n  }\r\n\r\n  // Ensure static entity is always assigned to a:\r\n  if (b.static) {\r\n    const c = a;\r\n    a = b;\r\n    b = c;\r\n  }\r\n\r\n  const dx = a.position\r\n    .clone()\r\n    .subtract(b.position)\r\n    .set_length(a.radius + b.radius);\r\n  const du = a.velocity.clone().subtract(b.velocity);\r\n\r\n  const coefficient_of_restitution = 0.5 * (a.elasticity + b.elasticity);\r\n  const response =\r\n    (coefficient_of_restitution * 2 * du.dot(dx)) /\r\n    ((a.mass + b.mass) * dx.length_squared());\r\n\r\n  if (!a.static) {\r\n    a.velocity.subtract(dx.clone().scale(response * b.mass));\r\n  }\r\n  if (!b.static) {\r\n    b.velocity.subtract(dx.clone().scale(-response * a.mass));\r\n  }\r\n}\r\n\r\n// Moves entities a minimum distance away from each other.\r\nexport function separate_entities(a: Entity, b: Entity, distance: number) {\r\n  if (a.static && b.static) {\r\n    return;\r\n  }\r\n\r\n  const r = a.radius + b.radius + distance;\r\n  const d2 = a.position.distance_squared_to(b.position);\r\n\r\n  if (d2 >= r * r) {\r\n    return;\r\n  }\r\n\r\n  const collision_axis = a.position.clone().subtract(b.position).normalize();\r\n  const offset_magnitude = r - Math.sqrt(d2);\r\n\r\n  if (a.static) {\r\n    b.position.add(collision_axis.scale(-offset_magnitude));\r\n  } else if (b.static) {\r\n    a.position.add(collision_axis.scale(offset_magnitude));\r\n  } else {\r\n    a.position.add(collision_axis.clone().scale(0.5 * offset_magnitude));\r\n    b.position.add(collision_axis.clone().scale(0.5 * -offset_magnitude));\r\n  }\r\n}\r\n","export class BoundingBox {\r\n  readonly bottom: number;\r\n  readonly right: number;\r\n\r\n  constructor(\r\n    readonly top: number,\r\n    readonly left: number,\r\n    readonly width: number,\r\n    readonly height: number\r\n  ) {\r\n    this.bottom = this.top - this.height;\r\n    this.right = this.left + this.width;\r\n  }\r\n\r\n  static from_center_and_radius(\r\n    center_x: number,\r\n    center_y: number,\r\n    radius: number\r\n  ): BoundingBox {\r\n    return new BoundingBox(\r\n      center_y + radius,\r\n      center_x - radius,\r\n      radius,\r\n      radius\r\n    );\r\n  }\r\n\r\n  overlaps(other: BoundingBox): boolean {\r\n    return (\r\n      other.left <= this.right &&\r\n      other.right >= this.left &&\r\n      other.bottom <= this.top &&\r\n      other.top >= this.bottom\r\n    );\r\n  }\r\n}\r\n\r\nexport class QuadTree<T> {\r\n  constructor(readonly depth: number, readonly bounds: BoundingBox) {\r\n    if (this.depth < 1) {\r\n      throw new Error(\"quadtree node cannot have depth < 1\");\r\n    } else if (this.depth === 1) {\r\n      this.node = { kind: \"leaf\", items: [] };\r\n    } else if (this.depth > 1) {\r\n      const child_depth = depth - 1;\r\n      const y = this.bounds.top;\r\n      const x = this.bounds.left;\r\n      const w2 = 0.5 * this.bounds.width;\r\n      const h2 = 0.5 * this.bounds.height;\r\n      this.node = {\r\n        kind: \"internal\",\r\n        sw: new QuadTree(child_depth, new BoundingBox(y - h2, x, w2, h2)),\r\n        se: new QuadTree(child_depth, new BoundingBox(y - h2, x + w2, w2, h2)),\r\n        nw: new QuadTree(child_depth, new BoundingBox(y, x, w2, h2)),\r\n        ne: new QuadTree(child_depth, new BoundingBox(y, x + w2, w2, h2)),\r\n      };\r\n    }\r\n  }\r\n\r\n  nr_items(): number {\r\n    if (this.node.kind === \"leaf\") {\r\n      return this.node.items.length;\r\n    } else {\r\n      let sum = 0;\r\n      this.for_each_child((child) => (sum += child.nr_items()));\r\n      return sum;\r\n    }\r\n  }\r\n\r\n  clear() {\r\n    if (this.node.kind === \"leaf\") {\r\n      this.node.items.length = 0;\r\n    } else {\r\n      this.for_each_child((child) => child.clear());\r\n    }\r\n  }\r\n\r\n  add(entity: T, target_bounds: BoundingBox): void {\r\n    if (!target_bounds.overlaps(this.bounds)) {\r\n      return;\r\n    } else if (this.node.kind === \"internal\") {\r\n      this.for_each_child((child) => {\r\n        if (child.bounds.overlaps(target_bounds)) {\r\n          child.add(entity, target_bounds);\r\n        }\r\n      });\r\n    } else if (!this.node.items.includes(entity)) {\r\n      this.node.items.push(entity);\r\n    }\r\n  }\r\n\r\n  remove(entity: T, target_bounds: BoundingBox): void {\r\n    if (!target_bounds.overlaps(this.bounds)) {\r\n      return;\r\n    } else if (this.node.kind === \"internal\") {\r\n      this.for_each_child((child) => {\r\n        if (child.bounds.overlaps(target_bounds)) {\r\n          child.remove(entity, target_bounds);\r\n        }\r\n      });\r\n    } else if (this.node.items.includes(entity)) {\r\n      const index = this.node.items.indexOf(entity);\r\n      this.node.items.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  for_each_child(callback: (node: QuadTree<T>) => void) {\r\n    if (this.node.kind === \"leaf\") {\r\n      return;\r\n    }\r\n    callback(this.node.sw);\r\n    callback(this.node.se);\r\n    callback(this.node.nw);\r\n    callback(this.node.ne);\r\n  }\r\n\r\n  for_each_leaf_with_at_least(\r\n    threshold: number,\r\n    callback: (items: T[]) => void\r\n  ) {\r\n    if (this.nr_items() < threshold) {\r\n      return;\r\n    } else if (this.node.kind === \"leaf\") {\r\n      callback(this.node.items);\r\n    } else {\r\n      this.for_each_child((child) =>\r\n        child.for_each_leaf_with_at_least(threshold, callback)\r\n      );\r\n    }\r\n  }\r\n\r\n  private readonly node:\r\n    | { kind: \"leaf\"; items: T[] }\r\n    | {\r\n        kind: \"internal\";\r\n        sw: QuadTree<T>;\r\n        se: QuadTree<T>;\r\n        nw: QuadTree<T>;\r\n        ne: QuadTree<T>;\r\n      } = { kind: \"leaf\", items: [] };\r\n}\r\n"],"names":["$79bdaf91ddabfb91$export$ac4bca90992eed1","constructor","x","y","clone","assign","other","normalize","factor","length","set_length","scalar","add","subtract","scale","dot","length_squared","Math","sqrt","distance_squared_to","dx","dy","$b1d81ba20a88f1e6$export$63080c4de6cfc362","top","left","width","height","bottom","right","from_center_and_radius","center_x","center_y","radius","overlaps","$b1d81ba20a88f1e6$export$b82688eb02220411","depth","bounds","node","kind","items","Error","child_depth","w2","h2","sw","se","nw","ne","nr_items","sum","for_each_child","child","clear","entity","target_bounds","includes","push","remove","index","indexOf","splice","callback","for_each_leaf_with_at_least","threshold","$296bc57a304a4f5f$export$2e2bcd8739ae039","options","quadtree","subdivisions","bounds_size","position","moved","old_position","old_bounds","new_bounds","for_each_potential_collision_group","$296bc57a304a4f5f$export$fd0a61d200b47931","entities","collisions","j","a","k","b","static","center_1","radius_1","center_2","radius_2","$296bc57a304a4f5f$export$7b62f1d061fe35d9","c","du","velocity","response","coefficient_of_restitution","elasticity","mass","$296bc57a304a4f5f$export$9acaec0c61023416","distance","r","d2","collision_axis","offset_magnitude","$12fff36ccf056a0a$var$step_entity","dt","f","applied_force","m_inv","p","v","$12fff36ccf056a0a$export$812cd9544993280d","next_entity_id","Map","collision_culler","collision_culling_subdivisions","size","spawn","undefined","id","set","entity_id","has","get","delete","update","for_each_entity","forEach","_entity","step","separate_colliding_entities","high_precision","step_with_high_precision","step_with_low_precision","old_entity_positions","group","intersecting_pairs","entity_1","entity_2","stepped_entities","Set","i","step_entity_group","previous_position","t","earliest_collision","collision","time_horizon","$296bc57a304a4f5f$var$collision_time","c1","v1","r1","c2","v2","r2","dv_x","dv_y","dc_x","dc_y","solution","$296bc57a304a4f5f$var$quadratic_solution","b2_4ac","count","x1","x2","dv_x2","dc_x2","t1","t2","time","time_step","$a75101aa2d33e430$var$PALETTE","$a75101aa2d33e430$var$random_in_range","lower","upper","random","window","addEventListener","entity_styles","world","PI","fill","canvas_elements","document","getElementsByClassName","canvas","item","HTMLCanvasElement","context","getContext","alpha","controls","clear_color","frame_callback","frame_request","last_frame_time","on_animation_frame","now","performance","real_dt","$92df0325268d5d47$var$render_world_frame","save","fillStyle","fillRect","translate","parseInt","beginPath","arc","restore","requestAnimationFrame","pause","cancelAnimationFrame","resume","total_velocity","update_required"],"version":3,"file":"index.90a087fa.js.map"}