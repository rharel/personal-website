{"mappings":"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","sources":["<anon>","projects/fluid-simulation/demo.ts","projects/fluid-simulation/vertex_shader.vert","projects/fluid-simulation/fragment_shader.frag","projects/fluid-simulation/webgl_utilities.ts"],"sourcesContent":["\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n// The fluid simulation implementation here follows the Real-Time Fluid Dynamics paper by Jos Stam.\n// http://graphics.cs.cmu.edu/nsp/course/15-464/Fall09/papers/StamFluidforGames.pdf\n// @ts-ignore because Parcel handles this import.\nvar $444a1f9845a7b67c$exports = {};\n$444a1f9845a7b67c$exports = \"#version 100\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nattribute vec2 position;\\nvarying vec2 cell_center;\\n\\nvoid main() {\\n    cell_center = (position + 1.0) / 2.0;\\n    gl_Position = vec4(position, 0, 1);\\n}\\n\";\n\n\nvar $4407b64e9cb6b8b7$exports = {};\n$4407b64e9cb6b8b7$exports = \"// The fluid simulation implementation here follows the Real-Time Fluid Dynamics paper by Jos Stam.\\n// http://graphics.cs.cmu.edu/nsp/course/15-464/Fall09/papers/StamFluidforGames.pdf\\n\\n#version 100\\nprecision mediump float;\\n#define GLSLIFY 1\\n\\n#define DEBUG_VELOCITY 0\\n\\n// Instead of a separate shader program for each rendering pass, we use one program with a uniform\\n// variable as a pass discriminator.\\nconst int COPY_PASS_KIND = 0;\\nconst int DENSITY_SOURCE_PASS_KIND = 1;\\nconst int DENSITY_DIFFUSION_PASS_KIND = 2;\\nconst int DENSITY_ADVECTION_PASS_KIND = 3;\\nconst int VELOCITY_SOURCE_PASS_KIND = 4;\\nconst int VELOCITY_DIFFUSION_PASS_KIND = 5;\\nconst int VELOCITY_ADVECTION_PASS_KIND = 6;\\nconst int VELOCITY_PROJECTION_STEP_1_PASS_KIND = 7;\\nconst int VELOCITY_PROJECTION_STEP_2_PASS_KIND = 8;\\nconst int VELOCITY_PROJECTION_STEP_3_PASS_KIND = 9;\\nuniform int pass_kind;\\n\\n// These textures have semantics depending on the render pass kind. \\nuniform sampler2D texture_0;\\nuniform sampler2D texture_1;\\n\\nuniform float cell_size;\\nuniform float diffusion_rate;\\nuniform float dissipation_rate;\\nuniform float dt;\\n\\nvarying vec2 cell_center;\\n\\nvec3 rgb_from_hsv(const vec3 color) {\\n    // https://stackoverflow.com/a/17897228\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(color.xxx + K.xyz) * 6.0 - K.www);\\n    return color.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), color.y);\\n}\\n\\nvec3 cell(const sampler2D texture, const int i, const int j) {\\n    // Use a modulo on the coordinate so the grid wraps around itself.\\n    vec2 texel_coordinate = mod((vec2(i, j) + 0.5) * cell_size, 1.0);\\n    return texture2D(texture, texel_coordinate).xyz;\\n}\\nvec3 cell(const int i, const int j) {\\n    return cell(texture_0, i, j);\\n}\\n\\nvec2 velocity(const vec3 texel) {\\n    return texel.xy;\\n}\\nvec2 velocity(const sampler2D texture, const int i, const int j) {\\n    return velocity(cell(texture, i, j));\\n}\\nvec2 velocity(const int i, const int j) {\\n    return velocity(cell(i, j));\\n}\\n\\nfloat density(const vec3 texel) {\\n    return texel.z;\\n}\\nfloat density(const sampler2D texture, const int i, const int j) {\\n    return density(cell(texture, i, j));\\n}\\nfloat density(const int i, const int j) {\\n    return density(cell(i, j));\\n}\\n\\nvec3 diffusion(const int i, const int j) {\\n    float grid_size = 1.0 / cell_size;\\n    float diffusion_factor = diffusion_rate * grid_size * grid_size * dt;\\n    vec3 pre_diffusion_cell = cell(texture_1, i, j);\\n    return (\\n        pre_diffusion_cell +\\n        diffusion_factor * (cell(i - 1, j) + cell(i + 1, j) + cell(i, j - 1) + cell(i, j + 1))) /\\n        (1.0 + 4.0 * diffusion_factor);\\n}\\n\\nvec3 advection(const int i, const int j) {\\n    float grid_size = 1.0 / cell_size;\\n    vec2 backtrace = clamp(vec2(i, j) - velocity(i, j) * grid_size * dt, 0.5, grid_size - 0.5);\\n    ivec2 ij_0 = ivec2(floor(backtrace));\\n    ivec2 ij_1 = ij_0 + 1;\\n    vec2 st_1 = backtrace - vec2(ij_0);\\n    vec2 st_0 = 1.0 - st_1;\\n    return st_0.x * (st_0.y * cell(ij_0.x, ij_0.y) + st_1.y * cell(ij_0.x, ij_1.y)) +\\n        st_1.x * (st_0.y * cell(ij_1.x, ij_0.y) + st_1.y * cell(ij_1.x, ij_1.y));\\n}\\n\\nvec2 projection_step_1(const int i, const int j) {\\n    float div =  -0.5 * cell_size * (\\n        velocity(i + 1, j).x - velocity(i - 1, j).x +\\n        velocity(i, j + 1).y - velocity(i, j - 1).y);\\n    return vec2(div, 0);\\n}\\n\\nvec2 projection_step_2(const int i, const int j) {\\n    float div = cell(i, j).x;\\n    float p = (\\n        div + \\n        cell(i - 1, j).y + cell(i + 1, j).y + \\n        cell(i, j - 1).y + cell(i, j + 1).y) / 4.0;\\n    return vec2(div, p);\\n}\\n\\nvec2 projection_step_3(const int i, const int j) {\\n    return velocity(i, j) - 0.5 * vec2(\\n        cell(texture_1, i + 1, j).y - cell(texture_1, i - 1, j).y, \\n        cell(texture_1, i, j + 1).y - cell(texture_1, i, j - 1).y) / cell_size;\\n}\\n\\nvoid main() {\\n    int i = int(cell_center.x / cell_size);\\n    int j = int(cell_center.y / cell_size);\\n\\n    if (pass_kind == COPY_PASS_KIND) {\\n        gl_FragColor = vec4(cell(i, j), 1);\\n        return;\\n    }\\n\\n    if (pass_kind == DENSITY_SOURCE_PASS_KIND) {\\n        float source = density(texture_1, i, j);\\n        float new_density = max(density(i, j) + (source - dissipation_rate) * dt, 0.0);\\n        gl_FragColor = vec4(velocity(i, j), new_density, 1);\\n        return;\\n    }\\n\\n    if (pass_kind == DENSITY_DIFFUSION_PASS_KIND) {\\n        gl_FragColor = vec4(velocity(i, j), density(diffusion(i, j)), 1);\\n        return;\\n    }\\n\\n    if (pass_kind == DENSITY_ADVECTION_PASS_KIND) {\\n        gl_FragColor = vec4(velocity(i, j), density(advection(i, j)), 1);\\n        return;\\n    }\\n\\n    if (pass_kind == VELOCITY_SOURCE_PASS_KIND) {\\n        vec2 source = velocity(texture_1, i, j);\\n        vec2 new_velocity = velocity(i, j) + source * dt;\\n        if (length(new_velocity) > 0.001) {\\n            float new_speed = max(length(new_velocity) - dissipation_rate * dt, 0.0);\\n            new_velocity = normalize(new_velocity) * new_speed;\\n        }\\n        gl_FragColor = vec4(new_velocity, density(i, j), 1);\\n        return;\\n    }\\n\\n    if (pass_kind == VELOCITY_DIFFUSION_PASS_KIND) {\\n        gl_FragColor = vec4(velocity(diffusion(i, j)), density(i, j), 1);\\n        return;\\n    }\\n\\n    if (pass_kind == VELOCITY_ADVECTION_PASS_KIND) {\\n        gl_FragColor = vec4(velocity(advection(i, j)), density(i, j), 1);\\n        return;\\n    }\\n\\n    if (pass_kind == VELOCITY_PROJECTION_STEP_1_PASS_KIND) {\\n        gl_FragColor = vec4(projection_step_1(i, j), 0, 1);\\n        return;\\n    }\\n\\n    if (pass_kind == VELOCITY_PROJECTION_STEP_2_PASS_KIND) {\\n        gl_FragColor = vec4(projection_step_2(i, j), 0, 1);\\n        return;\\n    }\\n\\n    if (pass_kind == VELOCITY_PROJECTION_STEP_3_PASS_KIND) {\\n        gl_FragColor = vec4(projection_step_3(i, j), density(i, j), 1);\\n        return;\\n    }\\n\\n#if DEBUG_VELOCITY\\n    float grid_size = 100.0 * cell_size;\\n    float hue = (degrees(atan(velocity(i, j).y, velocity(i, j).x)) + 180.0) / 360.0;\\n    float value = min(length(velocity(i, j)) / grid_size, 1.0);\\n    gl_FragColor = vec4(rgb_from_hsv(vec3(hue, 1, value)), 1);\\n#else\\n    float hue = (degrees(atan(velocity(i, j).y, velocity(i, j).x)) + 180.0) / 360.0;\\n    float value = density(i, j);\\n    gl_FragColor = vec4(rgb_from_hsv(vec3(hue, 1, value)), 1);\\n#endif      \\n}\\n\";\n\n\nfunction $e01d6e1b57fe2feb$export$b432d2a391137a85(gl) {\n    const error_code = gl.getError();\n    if (error_code == gl.NO_ERROR) return;\n    const error_name = error_code == gl.INVALID_ENUM ? \"INVALID_ENUM\" : error_code == gl.INVALID_VALUE ? \"INVALID_VALUE\" : error_code == gl.INVALID_OPERATION ? \"INVALID_OPERATION\" : error_code == gl.INVALID_FRAMEBUFFER_OPERATION ? \"INVALID_FRAMEBUFFER_OPERATION\" : error_code == gl.OUT_OF_MEMORY ? \"OUT_OF_MEMORY\" : error_code == gl.CONTEXT_LOST_WEBGL ? \"CONTEXT_LOST_WEBGL\" : \"unknown\";\n    throw new Error(`WebGL ${error_name} error (code ${error_code}).`);\n}\nfunction $e01d6e1b57fe2feb$export$9c3153902b5cadb5(gl, source, shader_type) {\n    const shader_type_name = shader_type == gl.VERTEX_SHADER ? \"vertex\" : shader_type == gl.FRAGMENT_SHADER ? \"fragment\" : `type-${shader_type}`;\n    const shader = gl.createShader(shader_type);\n    if (!shader) {\n        console.error(`Failed to create ${shader_type_name} shader.`);\n        return null;\n    }\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        console.error(`Failed to compile ${shader_type_name} shader: ${gl.getShaderInfoLog(shader)}`);\n        return null;\n    }\n    $e01d6e1b57fe2feb$export$b432d2a391137a85(gl);\n    return shader;\n}\nfunction $e01d6e1b57fe2feb$export$f1b60f3667a0b5d(gl, program, name) {\n    const location = gl.getAttribLocation(program, name);\n    if (location < 0) console.error(`Failed to get location for attribute '${name}'.`);\n    return location;\n}\nfunction $e01d6e1b57fe2feb$export$1b21c09da1b82d01(gl, program, name) {\n    const location = gl.getUniformLocation(program, name);\n    if (!location) console.error(`Failed to get location for uniform '${name}'.`);\n    return location;\n}\nfunction $e01d6e1b57fe2feb$export$47407766e6f157ce(gl, width, height, pixels) {\n    if (pixels && width * height * 4 != pixels.length) {\n        console.error(\"Pixel array size does not match texture dimensions.\");\n        return null;\n    }\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, pixels);\n    $e01d6e1b57fe2feb$export$b432d2a391137a85(gl);\n    return texture;\n}\nfunction $e01d6e1b57fe2feb$export$200c13bdb863a92c(gl, texture, x, y, width, height, pixels) {\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, width, height, gl.RGBA, gl.FLOAT, pixels);\n}\n\n\nconst $630c8bccf7fa832a$var$show_fps = false;\nconst $630c8bccf7fa832a$var$debug = false;\nfunction $630c8bccf7fa832a$var$debug_assert_ok(gl) {\n    if ($630c8bccf7fa832a$var$debug) (0, $e01d6e1b57fe2feb$export$b432d2a391137a85)(gl);\n}\nvar $630c8bccf7fa832a$var$PassKind;\n/// Instead of a separate shader program for each rendering pass, we use one program with a uniform\n/// index variable as a pass discriminator.\n(function(PassKind) {\n    PassKind[PassKind[\"Copy\"] = 0] = \"Copy\";\n    PassKind[PassKind[\"DensitySource\"] = 1] = \"DensitySource\";\n    PassKind[PassKind[\"DensityDiffusion\"] = 2] = \"DensityDiffusion\";\n    PassKind[PassKind[\"DensityAdvection\"] = 3] = \"DensityAdvection\";\n    PassKind[PassKind[\"VelocitySource\"] = 4] = \"VelocitySource\";\n    PassKind[PassKind[\"VelocityDiffusion\"] = 5] = \"VelocityDiffusion\";\n    PassKind[PassKind[\"VelocityAdvection\"] = 6] = \"VelocityAdvection\";\n    PassKind[PassKind[\"VelocityProjectionStep1\"] = 7] = \"VelocityProjectionStep1\";\n    PassKind[PassKind[\"VelocityProjectionStep2\"] = 8] = \"VelocityProjectionStep2\";\n    PassKind[PassKind[\"VelocityProjectionStep3\"] = 9] = \"VelocityProjectionStep3\";\n    PassKind[PassKind[\"Visualization\"] = 10] = \"Visualization\";\n})($630c8bccf7fa832a$var$PassKind || ($630c8bccf7fa832a$var$PassKind = {}));\nconst $630c8bccf7fa832a$var$brush_radius = 8;\nconst $630c8bccf7fa832a$var$brush_size = 2 * $630c8bccf7fa832a$var$brush_radius;\nfunction $630c8bccf7fa832a$var$set_brush_pixels(pixels, velocity_x, velocity_y, density) {\n    if (pixels.length != $630c8bccf7fa832a$var$brush_size * $630c8bccf7fa832a$var$brush_size * 4) {\n        console.error(\"Array size doesn't match brush dimensions.\");\n        return false;\n    }\n    for(let i = 0; i < $630c8bccf7fa832a$var$brush_size; ++i)for(let j = 0; j < $630c8bccf7fa832a$var$brush_size; ++j){\n        const distance_to_center_squared = (i - $630c8bccf7fa832a$var$brush_radius) * (i - $630c8bccf7fa832a$var$brush_radius) + (j - $630c8bccf7fa832a$var$brush_radius) * (j - $630c8bccf7fa832a$var$brush_radius);\n        if (distance_to_center_squared > $630c8bccf7fa832a$var$brush_radius * $630c8bccf7fa832a$var$brush_radius) continue;\n        const k = (i * $630c8bccf7fa832a$var$brush_size + j) * 4;\n        pixels[k + 0] = velocity_x;\n        pixels[k + 1] = velocity_y;\n        pixels[k + 2] = density;\n        pixels[k + 3] = 0;\n    }\n    return true;\n}\nfunction $630c8bccf7fa832a$var$begin_simulation(gl, program, flow_source, options) {\n    gl.useProgram(program);\n    const frame_buffer = gl.createFramebuffer();\n    if (!frame_buffer) {\n        console.error(\"Failed to create frame buffer.\");\n        return false;\n    }\n    const geometry_buffer = gl.createBuffer();\n    if (!geometry_buffer) {\n        console.error(\"Failed to create WebGL buffer.\");\n        return false;\n    }\n    const [_viewport_x, _viewport_y, viewport_width, viewport_height] = gl.getParameter(gl.VIEWPORT);\n    if (viewport_width != viewport_height) {\n        console.error(`Expected viewport to be square but it's ${viewport_width}x${viewport_height}.`);\n        return false;\n    }\n    // These we set only once.\n    gl.uniform1i((0, $e01d6e1b57fe2feb$export$1b21c09da1b82d01)(gl, program, \"texture_0\"), 0);\n    gl.uniform1i((0, $e01d6e1b57fe2feb$export$1b21c09da1b82d01)(gl, program, \"texture_1\"), 1);\n    gl.uniform1f((0, $e01d6e1b57fe2feb$export$1b21c09da1b82d01)(gl, program, \"cell_size\"), 1 / viewport_width);\n    gl.uniform1f((0, $e01d6e1b57fe2feb$export$1b21c09da1b82d01)(gl, program, \"dt\"), 1 / 60);\n    // These we'll be reusing.\n    const diffusion_rate_uniform = (0, $e01d6e1b57fe2feb$export$1b21c09da1b82d01)(gl, program, \"diffusion_rate\");\n    const dissipation_rate_uniform = (0, $e01d6e1b57fe2feb$export$1b21c09da1b82d01)(gl, program, \"dissipation_rate\");\n    const pass_kind_uniform = (0, $e01d6e1b57fe2feb$export$1b21c09da1b82d01)(gl, program, \"pass_kind\");\n    $630c8bccf7fa832a$var$debug_assert_ok(gl);\n    // We'll be rendering two triangles that cover the entire viewport.\n    const triangles = new Float32Array([\n        -1,\n        -1,\n        -1,\n        1,\n        1,\n        -1,\n        1,\n        -1,\n        -1,\n        1,\n        1,\n        1\n    ]);\n    gl.bindBuffer(gl.ARRAY_BUFFER, geometry_buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, triangles, gl.STATIC_DRAW);\n    $630c8bccf7fa832a$var$debug_assert_ok(gl);\n    const position_attribute = (0, $e01d6e1b57fe2feb$export$f1b60f3667a0b5d)(gl, program, \"position\");\n    gl.enableVertexAttribArray(position_attribute);\n    gl.vertexAttribPointer(position_attribute, 2, gl.FLOAT, false, 0, 0);\n    $630c8bccf7fa832a$var$debug_assert_ok(gl);\n    const zeroed_pixels = new Float32Array(viewport_width * viewport_height * 4);\n    const blank_texture = (0, $e01d6e1b57fe2feb$export$47407766e6f157ce)(gl, viewport_width, viewport_height, zeroed_pixels);\n    const texture_0 = (0, $e01d6e1b57fe2feb$export$47407766e6f157ce)(gl, viewport_width, viewport_height, zeroed_pixels);\n    const texture_1 = (0, $e01d6e1b57fe2feb$export$47407766e6f157ce)(gl, viewport_width, viewport_height, zeroed_pixels);\n    const texture_2 = (0, $e01d6e1b57fe2feb$export$47407766e6f157ce)(gl, viewport_width, viewport_height, zeroed_pixels);\n    const texture_3 = (0, $e01d6e1b57fe2feb$export$47407766e6f157ce)(gl, viewport_width, viewport_height, zeroed_pixels);\n    if (!blank_texture || !texture_0 || !texture_1 || !texture_2 || !texture_3) {\n        console.error(\"Failed to initialize textures.\");\n        return false;\n    }\n    function draw_pass(pass_kind, input_0, input_1, output) {\n        gl.uniform1i(pass_kind_uniform, pass_kind);\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, input_0);\n        gl.activeTexture(gl.TEXTURE1);\n        gl.bindTexture(gl.TEXTURE_2D, input_1);\n        if (output) {\n            gl.bindFramebuffer(gl.FRAMEBUFFER, frame_buffer);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, output, 0);\n        } else gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n        $630c8bccf7fa832a$var$debug_assert_ok(gl);\n    }\n    function copy(from, to) {\n        draw_pass(0, from, null, to);\n    }\n    function add_density_sources(input_flow, source, output_flow) {\n        gl.uniform1f(dissipation_rate_uniform, options.density_dissipation_rate);\n        draw_pass(1, input_flow, source, output_flow);\n    }\n    function diffuse_density(input_flow, intermediate, output_flow) {\n        copy(input_flow, intermediate);\n        gl.uniform1f(diffusion_rate_uniform, options.density_diffusion_rate);\n        let iteration_input = input_flow;\n        let iteration_output = output_flow;\n        for(let i = 0; i < options.nr_intermediate_iterations; ++i){\n            draw_pass(2, iteration_input, intermediate, iteration_output);\n            [iteration_input, iteration_output] = [\n                iteration_output,\n                iteration_input\n            ];\n        }\n        // Swap back after the last iteration.\n        [iteration_input, iteration_output] = [\n            iteration_output,\n            iteration_input\n        ];\n        // Ensure that at loop end the output texture contains the last iteration's output.\n        if (iteration_output != output_flow) copy(iteration_output, output_flow);\n    }\n    function advect_density(input_flow, output_flow) {\n        draw_pass(3, input_flow, null, output_flow);\n    }\n    function add_velocity_sources(input_flow, source, output_flow) {\n        gl.uniform1f(dissipation_rate_uniform, options.velocity_dissipation_rate);\n        draw_pass(4, input_flow, source, output_flow);\n    }\n    function diffuse_velocity(input_flow, intermediate, output_flow) {\n        copy(input_flow, intermediate);\n        gl.uniform1f(diffusion_rate_uniform, options.velocity_diffusion_rate);\n        let iteration_input = input_flow;\n        let iteration_output = output_flow;\n        for(let i = 0; i < options.nr_intermediate_iterations; ++i){\n            draw_pass(5, iteration_input, intermediate, iteration_output);\n            [iteration_input, iteration_output] = [\n                iteration_output,\n                iteration_input\n            ];\n        }\n        // Swap back after the last iteration.\n        [iteration_input, iteration_output] = [\n            iteration_output,\n            iteration_input\n        ];\n        // Ensure that at loop end the output texture contains the last iteration's output.\n        if (iteration_output != output_flow) copy(iteration_output, output_flow);\n    }\n    function advect_velocity(input_flow, output_flow) {\n        draw_pass(6, input_flow, null, output_flow);\n    }\n    function project_velocity(input_flow, intermediate, output_flow) {\n        draw_pass(7, input_flow, null, intermediate);\n        let iteration_input = intermediate;\n        let iteration_output = output_flow;\n        for(let i = 0; i < options.nr_intermediate_iterations; ++i){\n            draw_pass(8, iteration_input, null, iteration_output);\n            [iteration_input, iteration_output] = [\n                iteration_output,\n                iteration_input\n            ];\n        }\n        // Swap back after the last iteration.\n        [iteration_input, iteration_output] = [\n            iteration_output,\n            iteration_input\n        ];\n        // Ensure that at loop end the intermediate texture contains the last iteration's output.\n        if (iteration_output != intermediate) copy(iteration_output, intermediate);\n        draw_pass(9, input_flow, intermediate, output_flow);\n    }\n    function visualize(flow) {\n        draw_pass(10, flow, null, null);\n    }\n    // We'll be swapping these throughout. Using the output of one draw pass as input to the next.\n    let input_flow = texture_0;\n    let output_flow = texture_1;\n    function swap_input_and_output() {\n        [input_flow, output_flow] = [\n            output_flow,\n            input_flow\n        ];\n    }\n    const source_flow = texture_2;\n    const intermediate = texture_3;\n    const source_brush_pixels = new Float32Array($630c8bccf7fa832a$var$brush_size * $630c8bccf7fa832a$var$brush_size * 4);\n    const fps_element = document.getElementById(\"fps\");\n    const fps_stats = $630c8bccf7fa832a$var$show_fps && fps_element ? {\n        previous_frame_time: Date.now(),\n        recent_frame_rates: new Array(60),\n        next_frame_rate_index: 0,\n        element: fps_element\n    } : null;\n    const step_simulation = ()=>{\n        copy(blank_texture, source_flow);\n        if (flow_source.position && (flow_source.density > 0 || flow_source.needs_movement_processing)) {\n            const region_x = Math.max(0, flow_source.position.x - $630c8bccf7fa832a$var$brush_radius);\n            const region_y = Math.max(0, flow_source.position.y - $630c8bccf7fa832a$var$brush_radius);\n            const region_width = Math.min(viewport_width - region_x, $630c8bccf7fa832a$var$brush_size);\n            const region_height = Math.min(viewport_height - region_y, $630c8bccf7fa832a$var$brush_size);\n            $630c8bccf7fa832a$var$set_brush_pixels(source_brush_pixels, flow_source.velocity.x, flow_source.velocity.y, flow_source.density);\n            (0, $e01d6e1b57fe2feb$export$200c13bdb863a92c)(gl, source_flow, region_x, region_y, region_width, region_height, source_brush_pixels);\n            flow_source.needs_movement_processing = false;\n        }\n        add_velocity_sources(input_flow, source_flow, output_flow);\n        swap_input_and_output();\n        diffuse_velocity(input_flow, intermediate, output_flow);\n        swap_input_and_output();\n        project_velocity(input_flow, intermediate, output_flow);\n        swap_input_and_output();\n        advect_velocity(input_flow, output_flow);\n        swap_input_and_output();\n        project_velocity(input_flow, intermediate, output_flow);\n        swap_input_and_output();\n        add_density_sources(input_flow, source_flow, output_flow);\n        swap_input_and_output();\n        diffuse_density(input_flow, intermediate, output_flow);\n        swap_input_and_output();\n        advect_density(input_flow, output_flow);\n        visualize(output_flow);\n        swap_input_and_output();\n        if (fps_stats) {\n            const this_frame_time = Date.now();\n            const fps = 1000 / (this_frame_time - fps_stats.previous_frame_time);\n            fps_stats.previous_frame_time = this_frame_time;\n            fps_stats.recent_frame_rates[fps_stats.next_frame_rate_index] = fps;\n            fps_stats.next_frame_rate_index += 1;\n            fps_stats.next_frame_rate_index %= fps_stats.recent_frame_rates.length;\n            if (fps_stats.next_frame_rate_index == 0) {\n                const average_fps = fps_stats.recent_frame_rates.reduce((sum, item)=>sum + item) / fps_stats.recent_frame_rates.length;\n                fps_stats.element.textContent = `FPS: ${Math.floor(average_fps)}`;\n            }\n        }\n        requestAnimationFrame(step_simulation);\n    };\n    requestAnimationFrame(step_simulation);\n    return true;\n}\nfunction $630c8bccf7fa832a$var$inject_initial_flow(flow_source, center_x, center_y, radius, nr_puffs, density, velocity, total_duration_ms) {\n    return new Promise((resolve)=>{\n        function inject_puff(index) {\n            const angle = 2 * Math.PI / nr_puffs * index;\n            flow_source.position = {\n                x: center_x + Math.cos(angle) * radius,\n                y: center_y + Math.sin(angle) * radius\n            };\n            flow_source.velocity = {\n                x: Math.cos(angle) * velocity,\n                y: Math.sin(angle) * velocity\n            };\n            flow_source.density = density;\n            if (index + 1 < nr_puffs) setTimeout(()=>inject_puff(index + 1), total_duration_ms / nr_puffs);\n            else {\n                flow_source.density = 0;\n                resolve();\n            }\n        }\n        inject_puff(0);\n    });\n}\nfunction $630c8bccf7fa832a$var$setup_user_flow_source(flow_source, canvas) {\n    const pointer_position = (event)=>{\n        // Flip Y to match WebGL texture convention where zero is at the bottom.\n        return {\n            x: event.clientX - canvas.offsetLeft,\n            y: canvas.clientHeight - (event.clientY - canvas.offsetTop)\n        };\n    };\n    canvas.addEventListener(\"pointerdown\", (event)=>{\n        flow_source.position = pointer_position(event);\n        flow_source.density = 50;\n        canvas.setPointerCapture(event.pointerId);\n    });\n    canvas.addEventListener(\"pointerup\", (event)=>{\n        flow_source.density = 0;\n        canvas.releasePointerCapture(event.pointerId);\n    });\n    canvas.addEventListener(\"pointermove\", (event)=>{\n        const previous_position = Object.assign(pointer_position(event), flow_source.position);\n        flow_source.position = pointer_position(event);\n        flow_source.velocity.x = flow_source.position.x - previous_position.x;\n        flow_source.velocity.y = flow_source.position.y - previous_position.y;\n        flow_source.needs_movement_processing = true;\n    });\n}\nfunction $630c8bccf7fa832a$var$setup() {\n    const canvas = document.getElementById(\"demo-canvas\");\n    if (!(canvas instanceof HTMLCanvasElement)) {\n        console.error(`Expected a canvas element but got ${typeof canvas} instead.`);\n        return false;\n    }\n    // Match resolution to occupied space.\n    canvas.width = canvas.clientWidth;\n    canvas.height = canvas.clientHeight;\n    const gl = canvas.getContext(\"webgl\", {\n        alpha: false\n    });\n    if (!gl) {\n        console.error(\"Failed to get WebGL rendering context.\");\n        return false;\n    }\n    for (const extension of [\n        \"OES_texture_float\",\n        \"WEBGL_color_buffer_float\"\n    ])if (!gl.getExtension(extension)) {\n        console.error(`Required WebGL extension '${extension}' is unsupported.`);\n        return false;\n    }\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    const vertex_shader = (0, $e01d6e1b57fe2feb$export$9c3153902b5cadb5)(gl, (0, (/*@__PURE__*/$parcel$interopDefault($444a1f9845a7b67c$exports))), gl.VERTEX_SHADER);\n    if (!vertex_shader) {\n        console.error(\"Failed to compile vertex shader.\");\n        return false;\n    }\n    const fragment_shader = (0, $e01d6e1b57fe2feb$export$9c3153902b5cadb5)(gl, (0, (/*@__PURE__*/$parcel$interopDefault($4407b64e9cb6b8b7$exports))), gl.FRAGMENT_SHADER);\n    if (!fragment_shader) {\n        console.error(\"Failed to compile fragment shader.\");\n        return false;\n    }\n    const program = gl.createProgram();\n    if (!program) {\n        console.error(\"Failed to create WebGL program.\");\n        return false;\n    }\n    gl.attachShader(program, vertex_shader);\n    gl.attachShader(program, fragment_shader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error(`Failed to link WebGL program: ${gl.getProgramInfoLog(program)}`);\n        return false;\n    }\n    $630c8bccf7fa832a$var$debug_assert_ok(gl);\n    const flow_source = {\n        position: null,\n        velocity: {\n            x: 0,\n            y: 0\n        },\n        density: 0,\n        needs_movement_processing: false\n    };\n    const options = {\n        density_diffusion_rate: 0.00001,\n        density_dissipation_rate: 0.01,\n        velocity_diffusion_rate: 0,\n        velocity_dissipation_rate: 0.0001,\n        nr_intermediate_iterations: 20\n    };\n    if (!$630c8bccf7fa832a$var$begin_simulation(gl, program, flow_source, options)) {\n        console.error(\"Simulation aborted.\");\n        return false;\n    }\n    $630c8bccf7fa832a$var$inject_initial_flow(flow_source, canvas.width / 2, canvas.height / 2, /* radius: */ canvas.width / 10, /* nr. puffs: */ 30, /* density: */ 100, /* velocity: */ 10, /* duration ms: */ 1000).then(()=>$630c8bccf7fa832a$var$setup_user_flow_source(flow_source, canvas));\n    console.log(\"Simulation started.\");\n    return true;\n}\nwindow.addEventListener(\"DOMContentLoaded\", $630c8bccf7fa832a$var$setup, {\n    once: true\n});\n\n\n//# sourceMappingURL=index.db03fce4.js.map\n","// The fluid simulation implementation here follows the Real-Time Fluid Dynamics paper by Jos Stam.\r\n// http://graphics.cs.cmu.edu/nsp/course/15-464/Fall09/papers/StamFluidforGames.pdf\r\n\r\n// @ts-ignore because Parcel handles this import.\r\nimport vertex_shader_source from \"./vertex_shader.vert\";\r\n// @ts-ignore because Parcel handles this import.\r\nimport fragment_shader_source from \"./fragment_shader.frag\";\r\nimport { assert_ok, attribute_location, compiled_shader_from_source, new_rgba_float_texture, uniform_location, update_sub_image } from \"./webgl_utilities\";\r\n\r\nconst show_fps = false;\r\nconst debug = false;\r\nfunction debug_assert_ok(gl: WebGLRenderingContext) { if (debug) { assert_ok(gl); } }\r\n\r\ntype Vec2 = { x: number, y: number };\r\ntype FlowSource = {\r\n  position: Vec2 | null,\r\n  velocity: Vec2,\r\n  density: number,\r\n  needs_movement_processing: boolean,\r\n};\r\n\r\ntype SimulationOptions = {\r\n  density_diffusion_rate: number,\r\n  density_dissipation_rate: number,\r\n  velocity_diffusion_rate: number,\r\n  velocity_dissipation_rate: number,\r\n  nr_intermediate_iterations: number,\r\n};\r\n\r\n/// Instead of a separate shader program for each rendering pass, we use one program with a uniform\r\n/// index variable as a pass discriminator.\r\nenum PassKind {\r\n  Copy = 0,\r\n  DensitySource = 1,\r\n  DensityDiffusion = 2,\r\n  DensityAdvection = 3,\r\n  VelocitySource = 4,\r\n  VelocityDiffusion = 5,\r\n  VelocityAdvection = 6,\r\n  VelocityProjectionStep1 = 7,\r\n  VelocityProjectionStep2 = 8,\r\n  VelocityProjectionStep3 = 9,\r\n  Visualization = 10\r\n}\r\n\r\nconst brush_radius = 8;\r\nconst brush_size = 2 * brush_radius;\r\n\r\nfunction set_brush_pixels(pixels: Float32Array, velocity_x: number, velocity_y: number, density: number): boolean {\r\n  if (pixels.length != brush_size * brush_size * 4) {\r\n    console.error(\"Array size doesn't match brush dimensions.\");\r\n    return false;\r\n  }\r\n\r\n  for (let i = 0; i < brush_size; ++i) {\r\n    for (let j = 0; j < brush_size; ++j) {\r\n\r\n      const distance_to_center_squared =\r\n        (i - brush_radius) * (i - brush_radius) +\r\n        (j - brush_radius) * (j - brush_radius);\r\n\r\n      if (distance_to_center_squared > brush_radius * brush_radius) {\r\n        continue;\r\n      }\r\n\r\n      const k = (i * brush_size + j) * 4;\r\n      pixels[k + 0] = velocity_x;\r\n      pixels[k + 1] = velocity_y;\r\n      pixels[k + 2] = density;\r\n      pixels[k + 3] = 0;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction begin_simulation(\r\n  gl: WebGLRenderingContext,\r\n  program: WebGLProgram,\r\n  flow_source: FlowSource,\r\n  options: SimulationOptions): boolean {\r\n\r\n  gl.useProgram(program);\r\n\r\n  const frame_buffer = gl.createFramebuffer();\r\n  if (!frame_buffer) {\r\n    console.error(\"Failed to create frame buffer.\");\r\n    return false;\r\n  }\r\n\r\n  const geometry_buffer = gl.createBuffer();\r\n  if (!geometry_buffer) {\r\n    console.error(\"Failed to create WebGL buffer.\");\r\n    return false;\r\n  }\r\n\r\n  const [_viewport_x, _viewport_y, viewport_width, viewport_height] = gl.getParameter(gl.VIEWPORT);\r\n  if (viewport_width != viewport_height) {\r\n    console.error(`Expected viewport to be square but it's ${viewport_width}x${viewport_height}.`);\r\n    return false;\r\n  }\r\n\r\n  // These we set only once.\r\n  gl.uniform1i(uniform_location(gl, program, \"texture_0\"), 0);\r\n  gl.uniform1i(uniform_location(gl, program, \"texture_1\"), 1);\r\n  gl.uniform1f(uniform_location(gl, program, \"cell_size\"), 1 / viewport_width);\r\n  gl.uniform1f(uniform_location(gl, program, \"dt\"), 1 / 60);\r\n\r\n  // These we'll be reusing.\r\n  const diffusion_rate_uniform = uniform_location(gl, program, \"diffusion_rate\");\r\n  const dissipation_rate_uniform = uniform_location(gl, program, \"dissipation_rate\");\r\n  const pass_kind_uniform = uniform_location(gl, program, \"pass_kind\");\r\n\r\n  debug_assert_ok(gl);\r\n\r\n  // We'll be rendering two triangles that cover the entire viewport.\r\n  const triangles = new Float32Array([\r\n    -1, -1,\r\n    -1, +1,\r\n    +1, -1,\r\n\r\n    +1, -1,\r\n    -1, +1,\r\n    +1, +1,\r\n  ]);\r\n\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, geometry_buffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, triangles, gl.STATIC_DRAW);\r\n  debug_assert_ok(gl);\r\n\r\n  const position_attribute = attribute_location(gl, program, \"position\");\r\n  gl.enableVertexAttribArray(position_attribute);\r\n  gl.vertexAttribPointer(position_attribute, 2, gl.FLOAT, false, 0, 0);\r\n  debug_assert_ok(gl);\r\n\r\n  const zeroed_pixels = new Float32Array(viewport_width * viewport_height * 4);\r\n  const blank_texture = new_rgba_float_texture(gl, viewport_width, viewport_height, zeroed_pixels);\r\n  const texture_0 = new_rgba_float_texture(gl, viewport_width, viewport_height, zeroed_pixels);\r\n  const texture_1 = new_rgba_float_texture(gl, viewport_width, viewport_height, zeroed_pixels);\r\n  const texture_2 = new_rgba_float_texture(gl, viewport_width, viewport_height, zeroed_pixels);\r\n  const texture_3 = new_rgba_float_texture(gl, viewport_width, viewport_height, zeroed_pixels);\r\n  if (!blank_texture || !texture_0 || !texture_1 || !texture_2 || !texture_3) {\r\n    console.error(\"Failed to initialize textures.\");\r\n    return false;\r\n  }\r\n\r\n  function draw_pass(\r\n    pass_kind: PassKind,\r\n    input_0: WebGLTexture,\r\n    input_1: WebGLTexture | null,\r\n    output: WebGLTexture | null) {\r\n\r\n    gl.uniform1i(pass_kind_uniform, pass_kind);\r\n\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_2D, input_0);\r\n\r\n    gl.activeTexture(gl.TEXTURE1);\r\n    gl.bindTexture(gl.TEXTURE_2D, input_1);\r\n\r\n    if (output) {\r\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frame_buffer);\r\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, output, 0);\r\n    }\r\n    else {\r\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    }\r\n\r\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n    debug_assert_ok(gl);\r\n  }\r\n\r\n  function copy(from: WebGLTexture, to: WebGLTexture) {\r\n    draw_pass(PassKind.Copy, from, null, to);\r\n  }\r\n\r\n  function add_density_sources(input_flow: WebGLTexture, source: WebGLTexture, output_flow: WebGLTexture,) {\r\n    gl.uniform1f(dissipation_rate_uniform, options.density_dissipation_rate);\r\n    draw_pass(PassKind.DensitySource, input_flow, source, output_flow);\r\n  }\r\n\r\n  function diffuse_density(input_flow: WebGLTexture, intermediate: WebGLTexture, output_flow: WebGLTexture) {\r\n    copy(input_flow, intermediate);\r\n\r\n    gl.uniform1f(diffusion_rate_uniform, options.density_diffusion_rate);\r\n\r\n    let iteration_input = input_flow;\r\n    let iteration_output = output_flow;\r\n\r\n    for (let i = 0; i < options.nr_intermediate_iterations; ++i) {\r\n      draw_pass(PassKind.DensityDiffusion, iteration_input, intermediate, iteration_output);\r\n      [iteration_input, iteration_output] = [iteration_output, iteration_input]\r\n    }\r\n    // Swap back after the last iteration.\r\n    [iteration_input, iteration_output] = [iteration_output, iteration_input]\r\n\r\n    // Ensure that at loop end the output texture contains the last iteration's output.\r\n    if (iteration_output != output_flow) {\r\n      copy(iteration_output, output_flow);\r\n    }\r\n  }\r\n\r\n  function advect_density(input_flow: WebGLTexture, output_flow: WebGLTexture) {\r\n    draw_pass(PassKind.DensityAdvection, input_flow, null, output_flow);\r\n  }\r\n\r\n  function add_velocity_sources(input_flow: WebGLTexture, source: WebGLTexture, output_flow: WebGLTexture,) {\r\n    gl.uniform1f(dissipation_rate_uniform, options.velocity_dissipation_rate);\r\n    draw_pass(PassKind.VelocitySource, input_flow, source, output_flow);\r\n  }\r\n\r\n  function diffuse_velocity(input_flow: WebGLTexture, intermediate: WebGLTexture, output_flow: WebGLTexture) {\r\n    copy(input_flow, intermediate);\r\n\r\n    gl.uniform1f(diffusion_rate_uniform, options.velocity_diffusion_rate);\r\n\r\n    let iteration_input = input_flow;\r\n    let iteration_output = output_flow;\r\n\r\n    for (let i = 0; i < options.nr_intermediate_iterations; ++i) {\r\n      draw_pass(PassKind.VelocityDiffusion, iteration_input, intermediate, iteration_output);\r\n      [iteration_input, iteration_output] = [iteration_output, iteration_input]\r\n    }\r\n    // Swap back after the last iteration.\r\n    [iteration_input, iteration_output] = [iteration_output, iteration_input]\r\n\r\n    // Ensure that at loop end the output texture contains the last iteration's output.\r\n    if (iteration_output != output_flow) {\r\n      copy(iteration_output, output_flow);\r\n    }\r\n  }\r\n\r\n  function advect_velocity(input_flow: WebGLTexture, output_flow: WebGLTexture) {\r\n    draw_pass(PassKind.VelocityAdvection, input_flow, null, output_flow);\r\n  }\r\n\r\n  function project_velocity(input_flow: WebGLTexture, intermediate: WebGLTexture, output_flow: WebGLTexture) {\r\n    draw_pass(PassKind.VelocityProjectionStep1, input_flow, null, intermediate);\r\n\r\n    let iteration_input = intermediate;\r\n    let iteration_output = output_flow;\r\n\r\n    for (let i = 0; i < options.nr_intermediate_iterations; ++i) {\r\n      draw_pass(PassKind.VelocityProjectionStep2, iteration_input, null, iteration_output);\r\n      [iteration_input, iteration_output] = [iteration_output, iteration_input]\r\n    }\r\n    // Swap back after the last iteration.\r\n    [iteration_input, iteration_output] = [iteration_output, iteration_input]\r\n\r\n    // Ensure that at loop end the intermediate texture contains the last iteration's output.\r\n    if (iteration_output != intermediate) {\r\n      copy(iteration_output, intermediate);\r\n    }\r\n\r\n    draw_pass(PassKind.VelocityProjectionStep3, input_flow, intermediate, output_flow);\r\n  }\r\n\r\n  function visualize(flow: WebGLTexture) {\r\n    draw_pass(PassKind.Visualization, flow, null, null);\r\n  }\r\n\r\n  // We'll be swapping these throughout. Using the output of one draw pass as input to the next.\r\n  let input_flow = texture_0;\r\n  let output_flow = texture_1;\r\n  function swap_input_and_output() { [input_flow, output_flow] = [output_flow, input_flow]; }\r\n\r\n  const source_flow = texture_2;\r\n  const intermediate = texture_3;\r\n\r\n  const source_brush_pixels = new Float32Array(brush_size * brush_size * 4);\r\n\r\n  const fps_element = document.getElementById(\"fps\");\r\n  const fps_stats = (show_fps && fps_element) ? {\r\n    previous_frame_time: Date.now(),\r\n    recent_frame_rates: new Array<number>(60),\r\n    next_frame_rate_index: 0,\r\n    element: fps_element\r\n  } : null;\r\n\r\n  const step_simulation = () => {\r\n\r\n    copy(blank_texture, source_flow);\r\n\r\n    if (flow_source.position && (flow_source.density > 0 || flow_source.needs_movement_processing)) {\r\n      const region_x = Math.max(0, flow_source.position.x - brush_radius);\r\n      const region_y = Math.max(0, flow_source.position.y - brush_radius);\r\n      const region_width = Math.min(viewport_width - region_x, brush_size);\r\n      const region_height = Math.min(viewport_height - region_y, brush_size);\r\n      set_brush_pixels(source_brush_pixels, flow_source.velocity.x, flow_source.velocity.y, flow_source.density);\r\n      update_sub_image(gl, source_flow, region_x, region_y, region_width, region_height, source_brush_pixels);\r\n      flow_source.needs_movement_processing = false;\r\n    }\r\n\r\n    add_velocity_sources(input_flow, source_flow, output_flow);\r\n    swap_input_and_output();\r\n\r\n    diffuse_velocity(input_flow, intermediate, output_flow);\r\n    swap_input_and_output();\r\n\r\n    project_velocity(input_flow, intermediate, output_flow);\r\n    swap_input_and_output();\r\n\r\n    advect_velocity(input_flow, output_flow);\r\n    swap_input_and_output();\r\n\r\n    project_velocity(input_flow, intermediate, output_flow);\r\n    swap_input_and_output();\r\n\r\n    add_density_sources(input_flow, source_flow, output_flow);\r\n    swap_input_and_output();\r\n\r\n    diffuse_density(input_flow, intermediate, output_flow);\r\n    swap_input_and_output();\r\n\r\n    advect_density(input_flow, output_flow);\r\n    visualize(output_flow);\r\n    swap_input_and_output();\r\n\r\n    if (fps_stats) {\r\n      const this_frame_time = Date.now();\r\n      const fps = 1000 / (this_frame_time - fps_stats.previous_frame_time);\r\n      fps_stats.previous_frame_time = this_frame_time;\r\n\r\n      fps_stats.recent_frame_rates[fps_stats.next_frame_rate_index] = fps;\r\n      fps_stats.next_frame_rate_index += 1;\r\n      fps_stats.next_frame_rate_index %= fps_stats.recent_frame_rates.length;\r\n\r\n      if (fps_stats.next_frame_rate_index == 0) {\r\n        const average_fps =\r\n          fps_stats.recent_frame_rates.reduce((sum, item) => sum + item) /\r\n          fps_stats.recent_frame_rates.length;\r\n        fps_stats.element.textContent = `FPS: ${Math.floor(average_fps)}`;\r\n      }\r\n    }\r\n\r\n    requestAnimationFrame(step_simulation);\r\n  }\r\n\r\n  requestAnimationFrame(step_simulation);\r\n  return true;\r\n}\r\n\r\nfunction inject_initial_flow(\r\n  flow_source: FlowSource,\r\n  center_x: number, center_y: number,\r\n  radius: number, nr_puffs: number,\r\n  density: number, velocity: number,\r\n  total_duration_ms: number): Promise<void> {\r\n  return new Promise(resolve => {\r\n    function inject_puff(index: number) {\r\n      const angle = 2 * Math.PI / nr_puffs * index;\r\n      flow_source.position = {\r\n        x: center_x + Math.cos(angle) * radius,\r\n        y: center_y + Math.sin(angle) * radius,\r\n      };\r\n      flow_source.velocity = {\r\n        x: Math.cos(angle) * velocity,\r\n        y: Math.sin(angle) * velocity,\r\n      };\r\n      flow_source.density = density;\r\n\r\n      if (index + 1 < nr_puffs) {\r\n        setTimeout(() => inject_puff(index + 1), total_duration_ms / nr_puffs)\r\n      }\r\n      else {\r\n        flow_source.density = 0;\r\n        resolve();\r\n      }\r\n    }\r\n    inject_puff(0);\r\n  });\r\n}\r\n\r\nfunction setup_user_flow_source(flow_source: FlowSource, canvas: HTMLCanvasElement) {\r\n  const pointer_position = (event: PointerEvent) => {\r\n    // Flip Y to match WebGL texture convention where zero is at the bottom.\r\n    return {\r\n      x: event.clientX - canvas.offsetLeft,\r\n      y: canvas.clientHeight - (event.clientY - canvas.offsetTop)\r\n    };\r\n  }\r\n  canvas.addEventListener(\"pointerdown\", event => {\r\n    flow_source.position = pointer_position(event);\r\n    flow_source.density = 50;\r\n    canvas.setPointerCapture(event.pointerId);\r\n  });\r\n  canvas.addEventListener(\"pointerup\", event => {\r\n    flow_source.density = 0;\r\n    canvas.releasePointerCapture(event.pointerId);\r\n  });\r\n  canvas.addEventListener(\"pointermove\", event => {\r\n    const previous_position = Object.assign(pointer_position(event), flow_source.position);\r\n    flow_source.position = pointer_position(event);\r\n    flow_source.velocity.x = flow_source.position.x - previous_position.x;\r\n    flow_source.velocity.y = flow_source.position.y - previous_position.y;\r\n    flow_source.needs_movement_processing = true;\r\n  });\r\n}\r\n\r\nfunction setup(): boolean {\r\n  const canvas = document.getElementById(\"demo-canvas\");\r\n  if (!(canvas instanceof HTMLCanvasElement)) {\r\n    console.error(`Expected a canvas element but got ${typeof canvas} instead.`);\r\n    return false;\r\n  }\r\n\r\n  // Match resolution to occupied space.\r\n  canvas.width = canvas.clientWidth;\r\n  canvas.height = canvas.clientHeight;\r\n\r\n  const gl = canvas.getContext(\"webgl\", { alpha: false });\r\n  if (!gl) {\r\n    console.error(\"Failed to get WebGL rendering context.\");\r\n    return false;\r\n  }\r\n\r\n  for (const extension of [\"OES_texture_float\", \"WEBGL_color_buffer_float\"]) {\r\n    if (!gl.getExtension(extension)) {\r\n      console.error(`Required WebGL extension '${extension}' is unsupported.`);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n\r\n  const vertex_shader = compiled_shader_from_source(gl, vertex_shader_source, gl.VERTEX_SHADER);\r\n  if (!vertex_shader) {\r\n    console.error(\"Failed to compile vertex shader.\");\r\n    return false;\r\n  }\r\n\r\n  const fragment_shader = compiled_shader_from_source(gl, fragment_shader_source, gl.FRAGMENT_SHADER);\r\n  if (!fragment_shader) {\r\n    console.error(\"Failed to compile fragment shader.\");\r\n    return false;\r\n  }\r\n\r\n  const program = gl.createProgram();\r\n  if (!program) {\r\n    console.error(\"Failed to create WebGL program.\");\r\n    return false;\r\n  }\r\n\r\n  gl.attachShader(program, vertex_shader);\r\n  gl.attachShader(program, fragment_shader);\r\n  gl.linkProgram(program);\r\n\r\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n    console.error(`Failed to link WebGL program: ${gl.getProgramInfoLog(program)}`);\r\n    return false;\r\n  }\r\n\r\n  debug_assert_ok(gl);\r\n\r\n  const flow_source: FlowSource = {\r\n    position: null,\r\n    velocity: { x: 0, y: 0 },\r\n    density: 0,\r\n    needs_movement_processing: false,\r\n  };\r\n  const options: SimulationOptions = {\r\n    density_diffusion_rate: 0.00001,\r\n    density_dissipation_rate: 0.01,\r\n    velocity_diffusion_rate: 0,\r\n    velocity_dissipation_rate: 0.0001,\r\n    nr_intermediate_iterations: 20,\r\n  };\r\n\r\n  if (!begin_simulation(gl, program, flow_source, options)) {\r\n    console.error(\"Simulation aborted.\");\r\n    return false;\r\n  }\r\n\r\n  inject_initial_flow(\r\n    flow_source, canvas.width / 2, canvas.height / 2,\r\n    /* radius: */ canvas.width / 10,\r\n    /* nr. puffs: */ 30,\r\n    /* density: */ 100,\r\n    /* velocity: */ 10,\r\n    /* duration ms: */ 1000)\r\n    .then(() => setup_user_flow_source(flow_source, canvas));\r\n\r\n  console.log(\"Simulation started.\")\r\n  return true;\r\n}\r\n\r\nwindow.addEventListener(\"DOMContentLoaded\", setup, { once: true });\r\n","#version 100\r\nprecision highp float;\r\n\r\nattribute vec2 position;\r\nvarying vec2 cell_center;\r\n\r\nvoid main() {\r\n    cell_center = (position + 1.0) / 2.0;\r\n    gl_Position = vec4(position, 0, 1);\r\n}\r\n","// The fluid simulation implementation here follows the Real-Time Fluid Dynamics paper by Jos Stam.\r\n// http://graphics.cs.cmu.edu/nsp/course/15-464/Fall09/papers/StamFluidforGames.pdf\r\n\r\n#version 100\r\nprecision mediump float;\r\n\r\n#define DEBUG_VELOCITY 0\r\n\r\n// Instead of a separate shader program for each rendering pass, we use one program with a uniform\r\n// variable as a pass discriminator.\r\nconst int COPY_PASS_KIND = 0;\r\nconst int DENSITY_SOURCE_PASS_KIND = 1;\r\nconst int DENSITY_DIFFUSION_PASS_KIND = 2;\r\nconst int DENSITY_ADVECTION_PASS_KIND = 3;\r\nconst int VELOCITY_SOURCE_PASS_KIND = 4;\r\nconst int VELOCITY_DIFFUSION_PASS_KIND = 5;\r\nconst int VELOCITY_ADVECTION_PASS_KIND = 6;\r\nconst int VELOCITY_PROJECTION_STEP_1_PASS_KIND = 7;\r\nconst int VELOCITY_PROJECTION_STEP_2_PASS_KIND = 8;\r\nconst int VELOCITY_PROJECTION_STEP_3_PASS_KIND = 9;\r\nuniform int pass_kind;\r\n\r\n// These textures have semantics depending on the render pass kind. \r\nuniform sampler2D texture_0;\r\nuniform sampler2D texture_1;\r\n\r\nuniform float cell_size;\r\nuniform float diffusion_rate;\r\nuniform float dissipation_rate;\r\nuniform float dt;\r\n\r\nvarying vec2 cell_center;\r\n\r\nvec3 rgb_from_hsv(const vec3 color) {\r\n    // https://stackoverflow.com/a/17897228\r\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n    vec3 p = abs(fract(color.xxx + K.xyz) * 6.0 - K.www);\r\n    return color.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), color.y);\r\n}\r\n\r\nvec3 cell(const sampler2D texture, const int i, const int j) {\r\n    // Use a modulo on the coordinate so the grid wraps around itself.\r\n    vec2 texel_coordinate = mod((vec2(i, j) + 0.5) * cell_size, 1.0);\r\n    return texture2D(texture, texel_coordinate).xyz;\r\n}\r\nvec3 cell(const int i, const int j) {\r\n    return cell(texture_0, i, j);\r\n}\r\n\r\nvec2 velocity(const vec3 texel) {\r\n    return texel.xy;\r\n}\r\nvec2 velocity(const sampler2D texture, const int i, const int j) {\r\n    return velocity(cell(texture, i, j));\r\n}\r\nvec2 velocity(const int i, const int j) {\r\n    return velocity(cell(i, j));\r\n}\r\n\r\nfloat density(const vec3 texel) {\r\n    return texel.z;\r\n}\r\nfloat density(const sampler2D texture, const int i, const int j) {\r\n    return density(cell(texture, i, j));\r\n}\r\nfloat density(const int i, const int j) {\r\n    return density(cell(i, j));\r\n}\r\n\r\nvec3 diffusion(const int i, const int j) {\r\n    float grid_size = 1.0 / cell_size;\r\n    float diffusion_factor = diffusion_rate * grid_size * grid_size * dt;\r\n    vec3 pre_diffusion_cell = cell(texture_1, i, j);\r\n    return (\r\n        pre_diffusion_cell +\r\n        diffusion_factor * (cell(i - 1, j) + cell(i + 1, j) + cell(i, j - 1) + cell(i, j + 1))) /\r\n        (1.0 + 4.0 * diffusion_factor);\r\n}\r\n\r\nvec3 advection(const int i, const int j) {\r\n    float grid_size = 1.0 / cell_size;\r\n    vec2 backtrace = clamp(vec2(i, j) - velocity(i, j) * grid_size * dt, 0.5, grid_size - 0.5);\r\n    ivec2 ij_0 = ivec2(floor(backtrace));\r\n    ivec2 ij_1 = ij_0 + 1;\r\n    vec2 st_1 = backtrace - vec2(ij_0);\r\n    vec2 st_0 = 1.0 - st_1;\r\n    return st_0.x * (st_0.y * cell(ij_0.x, ij_0.y) + st_1.y * cell(ij_0.x, ij_1.y)) +\r\n        st_1.x * (st_0.y * cell(ij_1.x, ij_0.y) + st_1.y * cell(ij_1.x, ij_1.y));\r\n}\r\n\r\nvec2 projection_step_1(const int i, const int j) {\r\n    float div =  -0.5 * cell_size * (\r\n        velocity(i + 1, j).x - velocity(i - 1, j).x +\r\n        velocity(i, j + 1).y - velocity(i, j - 1).y);\r\n    return vec2(div, 0);\r\n}\r\n\r\nvec2 projection_step_2(const int i, const int j) {\r\n    float div = cell(i, j).x;\r\n    float p = (\r\n        div + \r\n        cell(i - 1, j).y + cell(i + 1, j).y + \r\n        cell(i, j - 1).y + cell(i, j + 1).y) / 4.0;\r\n    return vec2(div, p);\r\n}\r\n\r\nvec2 projection_step_3(const int i, const int j) {\r\n    return velocity(i, j) - 0.5 * vec2(\r\n        cell(texture_1, i + 1, j).y - cell(texture_1, i - 1, j).y, \r\n        cell(texture_1, i, j + 1).y - cell(texture_1, i, j - 1).y) / cell_size;\r\n}\r\n\r\nvoid main() {\r\n    int i = int(cell_center.x / cell_size);\r\n    int j = int(cell_center.y / cell_size);\r\n\r\n    if (pass_kind == COPY_PASS_KIND) {\r\n        gl_FragColor = vec4(cell(i, j), 1);\r\n        return;\r\n    }\r\n\r\n    if (pass_kind == DENSITY_SOURCE_PASS_KIND) {\r\n        float source = density(texture_1, i, j);\r\n        float new_density = max(density(i, j) + (source - dissipation_rate) * dt, 0.0);\r\n        gl_FragColor = vec4(velocity(i, j), new_density, 1);\r\n        return;\r\n    }\r\n\r\n    if (pass_kind == DENSITY_DIFFUSION_PASS_KIND) {\r\n        gl_FragColor = vec4(velocity(i, j), density(diffusion(i, j)), 1);\r\n        return;\r\n    }\r\n\r\n    if (pass_kind == DENSITY_ADVECTION_PASS_KIND) {\r\n        gl_FragColor = vec4(velocity(i, j), density(advection(i, j)), 1);\r\n        return;\r\n    }\r\n\r\n    if (pass_kind == VELOCITY_SOURCE_PASS_KIND) {\r\n        vec2 source = velocity(texture_1, i, j);\r\n        vec2 new_velocity = velocity(i, j) + source * dt;\r\n        if (length(new_velocity) > 0.001) {\r\n            float new_speed = max(length(new_velocity) - dissipation_rate * dt, 0.0);\r\n            new_velocity = normalize(new_velocity) * new_speed;\r\n        }\r\n        gl_FragColor = vec4(new_velocity, density(i, j), 1);\r\n        return;\r\n    }\r\n\r\n    if (pass_kind == VELOCITY_DIFFUSION_PASS_KIND) {\r\n        gl_FragColor = vec4(velocity(diffusion(i, j)), density(i, j), 1);\r\n        return;\r\n    }\r\n\r\n    if (pass_kind == VELOCITY_ADVECTION_PASS_KIND) {\r\n        gl_FragColor = vec4(velocity(advection(i, j)), density(i, j), 1);\r\n        return;\r\n    }\r\n\r\n    if (pass_kind == VELOCITY_PROJECTION_STEP_1_PASS_KIND) {\r\n        gl_FragColor = vec4(projection_step_1(i, j), 0, 1);\r\n        return;\r\n    }\r\n\r\n    if (pass_kind == VELOCITY_PROJECTION_STEP_2_PASS_KIND) {\r\n        gl_FragColor = vec4(projection_step_2(i, j), 0, 1);\r\n        return;\r\n    }\r\n\r\n    if (pass_kind == VELOCITY_PROJECTION_STEP_3_PASS_KIND) {\r\n        gl_FragColor = vec4(projection_step_3(i, j), density(i, j), 1);\r\n        return;\r\n    }\r\n\r\n#if DEBUG_VELOCITY\r\n    float grid_size = 100.0 * cell_size;\r\n    float hue = (degrees(atan(velocity(i, j).y, velocity(i, j).x)) + 180.0) / 360.0;\r\n    float value = min(length(velocity(i, j)) / grid_size, 1.0);\r\n    gl_FragColor = vec4(rgb_from_hsv(vec3(hue, 1, value)), 1);\r\n#else\r\n    float hue = (degrees(atan(velocity(i, j).y, velocity(i, j).x)) + 180.0) / 360.0;\r\n    float value = density(i, j);\r\n    gl_FragColor = vec4(rgb_from_hsv(vec3(hue, 1, value)), 1);\r\n#endif      \r\n}\r\n","export function assert_ok(gl: WebGLRenderingContext) {\r\n    const error_code = gl.getError();\r\n    if (error_code == gl.NO_ERROR) {\r\n        return;\r\n    }\r\n\r\n    const error_name = error_code == gl.INVALID_ENUM ? \"INVALID_ENUM\" :\r\n        error_code == gl.INVALID_VALUE ? \"INVALID_VALUE\" :\r\n            error_code == gl.INVALID_OPERATION ? \"INVALID_OPERATION\" :\r\n                error_code == gl.INVALID_FRAMEBUFFER_OPERATION ? \"INVALID_FRAMEBUFFER_OPERATION\" :\r\n                    error_code == gl.OUT_OF_MEMORY ? \"OUT_OF_MEMORY\" :\r\n                        error_code == gl.CONTEXT_LOST_WEBGL ? \"CONTEXT_LOST_WEBGL\" : \"unknown\";\r\n\r\n    throw new Error(`WebGL ${error_name} error (code ${error_code}).`);\r\n}\r\n\r\nexport function compiled_shader_from_source(gl: WebGLRenderingContext, source: string, shader_type: number): WebGLShader | null {\r\n    const shader_type_name =\r\n        shader_type == gl.VERTEX_SHADER ? \"vertex\" :\r\n            shader_type == gl.FRAGMENT_SHADER ? \"fragment\"\r\n                : `type-${shader_type}`;\r\n\r\n    const shader = gl.createShader(shader_type);\r\n    if (!shader) {\r\n        console.error(`Failed to create ${shader_type_name} shader.`);\r\n        return null;\r\n    }\r\n\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n\r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n        console.error(`Failed to compile ${shader_type_name} shader: ${gl.getShaderInfoLog(shader)}`);\r\n        return null;\r\n    }\r\n\r\n    assert_ok(gl);\r\n\r\n    return shader;\r\n}\r\n\r\nexport function attribute_location(gl: WebGLRenderingContext, program: WebGLProgram, name: string): number {\r\n    const location = gl.getAttribLocation(program, name);\r\n    if (location < 0) {\r\n        console.error(`Failed to get location for attribute '${name}'.`);\r\n    }\r\n    return location;\r\n}\r\n\r\nexport function uniform_location(gl: WebGLRenderingContext, program: WebGLProgram, name: string): WebGLUniformLocation | null {\r\n    const location = gl.getUniformLocation(program, name);\r\n    if (!location) {\r\n        console.error(`Failed to get location for uniform '${name}'.`);\r\n    }\r\n    return location;\r\n}\r\n\r\nexport function new_rgba_float_texture(gl: WebGLRenderingContext, width: number, height: number, pixels: Float32Array | null): WebGLTexture | null {\r\n    if (pixels && width * height * 4 != pixels.length) {\r\n        console.error(\"Pixel array size does not match texture dimensions.\");\r\n        return null;\r\n    }\r\n\r\n    const texture = gl.createTexture();\r\n\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n\r\n    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, pixels);\r\n\r\n    assert_ok(gl);\r\n\r\n    return texture;\r\n}\r\n\r\nexport function update_sub_image(gl: WebGLRenderingContext, texture: WebGLTexture, x: number, y: number, width: number, height: number, pixels: Float32Array) {\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, width, height, gl.RGBA, gl.FLOAT, pixels);\r\n}\r\n"],"names":["$parcel$interopDefault","a","__esModule","default","PassKind","$630c8bccf7fa832a$var$PassKind","$444a1f9845a7b67c$exports","$4407b64e9cb6b8b7$exports","$e01d6e1b57fe2feb$export$b432d2a391137a85","gl","error_code","getError","NO_ERROR","error_name","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL","Error","$e01d6e1b57fe2feb$export$9c3153902b5cadb5","source","shader_type","shader_type_name","VERTEX_SHADER","FRAGMENT_SHADER","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","error","getShaderInfoLog","$e01d6e1b57fe2feb$export$1b21c09da1b82d01","program","name","location","getUniformLocation","$e01d6e1b57fe2feb$export$47407766e6f157ce","width","height","pixels","length","texture","createTexture","bindTexture","TEXTURE_2D","texParameterf","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","texImage2D","RGBA","FLOAT","window","addEventListener","center_x","center_y","radius","canvas","document","getElementById","HTMLCanvasElement","clientWidth","clientHeight","getContext","alpha","extension","getExtension","viewport","drawingBufferWidth","drawingBufferHeight","vertex_shader","fragment_shader","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","flow_source","position","velocity","x","y","density","needs_movement_processing","$630c8bccf7fa832a$var$begin_simulation","options","useProgram","frame_buffer","createFramebuffer","geometry_buffer","createBuffer","_viewport_x","_viewport_y","viewport_width","viewport_height","getParameter","VIEWPORT","uniform1i","uniform1f","diffusion_rate_uniform","dissipation_rate_uniform","pass_kind_uniform","triangles","Float32Array","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","position_attribute","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","zeroed_pixels","blank_texture","texture_0","texture_1","texture_2","texture_3","draw_pass","pass_kind","input_0","input_1","output","activeTexture","TEXTURE0","TEXTURE1","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","drawArrays","TRIANGLES","copy","from","to","project_velocity","input_flow","intermediate","output_flow","iteration_input","iteration_output","i","nr_intermediate_iterations","swap_input_and_output","source_brush_pixels","$630c8bccf7fa832a$var$brush_size","step_simulation","region_x","Math","max","region_y","region_width","min","region_height","$630c8bccf7fa832a$var$set_brush_pixels","velocity_x","velocity_y","j","distance_to_center_squared","$630c8bccf7fa832a$var$brush_radius","k","texSubImage2D","velocity_dissipation_rate","diffuse_velocity","velocity_diffusion_rate","density_dissipation_rate","diffuse_density","density_diffusion_rate","requestAnimationFrame","$630c8bccf7fa832a$var$inject_initial_flow","Promise","resolve","inject_puff","index","angle","PI","cos","sin","setTimeout","total_duration_ms","then","$630c8bccf7fa832a$var$setup_user_flow_source","pointer_position","event","clientX","offsetLeft","clientY","offsetTop","setPointerCapture","pointerId","releasePointerCapture","previous_position","Object","assign","log","once"],"version":3,"file":"index.db03fce4.js.map"}