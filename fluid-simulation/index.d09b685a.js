!function(){function e(e){return e&&e.__esModule?e.default:e}var n,t,i={};i="#version 100\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec2 position;\nvarying vec2 cell_center;\n\nvoid main() {\n    cell_center = (position + 1.0) / 2.0;\n    gl_Position = vec4(position, 0, 1);\n}\n";var o={};function r(e){let n=e.getError();if(n==e.NO_ERROR)return;let t=n==e.INVALID_ENUM?"INVALID_ENUM":n==e.INVALID_VALUE?"INVALID_VALUE":n==e.INVALID_OPERATION?"INVALID_OPERATION":n==e.INVALID_FRAMEBUFFER_OPERATION?"INVALID_FRAMEBUFFER_OPERATION":n==e.OUT_OF_MEMORY?"OUT_OF_MEMORY":n==e.CONTEXT_LOST_WEBGL?"CONTEXT_LOST_WEBGL":"unknown";throw Error(`WebGL ${t} error (code ${n}).`)}function l(e,n,t){let i=t==e.VERTEX_SHADER?"vertex":t==e.FRAGMENT_SHADER?"fragment":`type-${t}`,o=e.createShader(t);return o?(e.shaderSource(o,n),e.compileShader(o),e.getShaderParameter(o,e.COMPILE_STATUS))?(r(e),o):(console.error(`Failed to compile ${i} shader: ${e.getShaderInfoLog(o)}`),null):(console.error(`Failed to create ${i} shader.`),null)}function c(e,n,t){let i=e.getUniformLocation(n,t);return i||console.error(`Failed to get location for uniform '${t}'.`),i}function s(e,n,t,i){if(i&&n*t*4!=i.length)return console.error("Pixel array size does not match texture dimensions."),null;let o=e.createTexture();return e.bindTexture(e.TEXTURE_2D,o),e.texParameterf(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameterf(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameterf(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameterf(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n,t,0,e.RGBA,e.FLOAT,i),r(e),o}o="// The fluid simulation implementation here follows the Real-Time Fluid Dynamics paper by Jos Stam.\n// http://graphics.cs.cmu.edu/nsp/course/15-464/Fall09/papers/StamFluidforGames.pdf\n\n#version 100\nprecision mediump float;\n#define GLSLIFY 1\n\n#define DEBUG_VELOCITY 0\n\n// Instead of a separate shader program for each rendering pass, we use one program with a uniform\n// variable as a pass discriminator.\nconst int COPY_PASS_KIND = 0;\nconst int DENSITY_SOURCE_PASS_KIND = 1;\nconst int DENSITY_DIFFUSION_PASS_KIND = 2;\nconst int DENSITY_ADVECTION_PASS_KIND = 3;\nconst int VELOCITY_SOURCE_PASS_KIND = 4;\nconst int VELOCITY_DIFFUSION_PASS_KIND = 5;\nconst int VELOCITY_ADVECTION_PASS_KIND = 6;\nconst int VELOCITY_PROJECTION_STEP_1_PASS_KIND = 7;\nconst int VELOCITY_PROJECTION_STEP_2_PASS_KIND = 8;\nconst int VELOCITY_PROJECTION_STEP_3_PASS_KIND = 9;\nuniform int pass_kind;\n\n// These textures have semantics depending on the render pass kind. \nuniform sampler2D texture_0;\nuniform sampler2D texture_1;\n\nuniform float cell_size;\nuniform float diffusion_rate;\nuniform float dissipation_rate;\nuniform float dt;\n\nvarying vec2 cell_center;\n\nvec3 rgb_from_hsv(const vec3 color) {\n    // https://stackoverflow.com/a/17897228\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(color.xxx + K.xyz) * 6.0 - K.www);\n    return color.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), color.y);\n}\n\nvec3 cell(const sampler2D texture, const int i, const int j) {\n    // Use a modulo on the coordinate so the grid wraps around itself.\n    vec2 texel_coordinate = mod((vec2(i, j) + 0.5) * cell_size, 1.0);\n    return texture2D(texture, texel_coordinate).xyz;\n}\nvec3 cell(const int i, const int j) {\n    return cell(texture_0, i, j);\n}\n\nvec2 velocity(const vec3 texel) {\n    return texel.xy;\n}\nvec2 velocity(const sampler2D texture, const int i, const int j) {\n    return velocity(cell(texture, i, j));\n}\nvec2 velocity(const int i, const int j) {\n    return velocity(cell(i, j));\n}\n\nfloat density(const vec3 texel) {\n    return texel.z;\n}\nfloat density(const sampler2D texture, const int i, const int j) {\n    return density(cell(texture, i, j));\n}\nfloat density(const int i, const int j) {\n    return density(cell(i, j));\n}\n\nvec3 diffusion(const int i, const int j) {\n    float grid_size = 1.0 / cell_size;\n    float diffusion_factor = diffusion_rate * grid_size * grid_size * dt;\n    vec3 pre_diffusion_cell = cell(texture_1, i, j);\n    return (\n        pre_diffusion_cell +\n        diffusion_factor * (cell(i - 1, j) + cell(i + 1, j) + cell(i, j - 1) + cell(i, j + 1))) /\n        (1.0 + 4.0 * diffusion_factor);\n}\n\nvec3 advection(const int i, const int j) {\n    float grid_size = 1.0 / cell_size;\n    vec2 backtrace = clamp(vec2(i, j) - velocity(i, j) * grid_size * dt, 0.5, grid_size - 0.5);\n    ivec2 ij_0 = ivec2(floor(backtrace));\n    ivec2 ij_1 = ij_0 + 1;\n    vec2 st_1 = backtrace - vec2(ij_0);\n    vec2 st_0 = 1.0 - st_1;\n    return st_0.x * (st_0.y * cell(ij_0.x, ij_0.y) + st_1.y * cell(ij_0.x, ij_1.y)) +\n        st_1.x * (st_0.y * cell(ij_1.x, ij_0.y) + st_1.y * cell(ij_1.x, ij_1.y));\n}\n\nvec2 projection_step_1(const int i, const int j) {\n    float div =  -0.5 * cell_size * (\n        velocity(i + 1, j).x - velocity(i - 1, j).x +\n        velocity(i, j + 1).y - velocity(i, j - 1).y);\n    return vec2(div, 0);\n}\n\nvec2 projection_step_2(const int i, const int j) {\n    float div = cell(i, j).x;\n    float p = (\n        div + \n        cell(i - 1, j).y + cell(i + 1, j).y + \n        cell(i, j - 1).y + cell(i, j + 1).y) / 4.0;\n    return vec2(div, p);\n}\n\nvec2 projection_step_3(const int i, const int j) {\n    return velocity(i, j) - 0.5 * vec2(\n        cell(texture_1, i + 1, j).y - cell(texture_1, i - 1, j).y, \n        cell(texture_1, i, j + 1).y - cell(texture_1, i, j - 1).y) / cell_size;\n}\n\nvoid main() {\n    int i = int(cell_center.x / cell_size);\n    int j = int(cell_center.y / cell_size);\n\n    if (pass_kind == COPY_PASS_KIND) {\n        gl_FragColor = vec4(cell(i, j), 1);\n        return;\n    }\n\n    if (pass_kind == DENSITY_SOURCE_PASS_KIND) {\n        float source = density(texture_1, i, j);\n        float new_density = max(density(i, j) + (source - dissipation_rate) * dt, 0.0);\n        gl_FragColor = vec4(velocity(i, j), new_density, 1);\n        return;\n    }\n\n    if (pass_kind == DENSITY_DIFFUSION_PASS_KIND) {\n        gl_FragColor = vec4(velocity(i, j), density(diffusion(i, j)), 1);\n        return;\n    }\n\n    if (pass_kind == DENSITY_ADVECTION_PASS_KIND) {\n        gl_FragColor = vec4(velocity(i, j), density(advection(i, j)), 1);\n        return;\n    }\n\n    if (pass_kind == VELOCITY_SOURCE_PASS_KIND) {\n        vec2 source = velocity(texture_1, i, j);\n        vec2 new_velocity = velocity(i, j) + source * dt;\n        if (length(new_velocity) > 0.001) {\n            float new_speed = max(length(new_velocity) - dissipation_rate * dt, 0.0);\n            new_velocity = normalize(new_velocity) * new_speed;\n        }\n        gl_FragColor = vec4(new_velocity, density(i, j), 1);\n        return;\n    }\n\n    if (pass_kind == VELOCITY_DIFFUSION_PASS_KIND) {\n        gl_FragColor = vec4(velocity(diffusion(i, j)), density(i, j), 1);\n        return;\n    }\n\n    if (pass_kind == VELOCITY_ADVECTION_PASS_KIND) {\n        gl_FragColor = vec4(velocity(advection(i, j)), density(i, j), 1);\n        return;\n    }\n\n    if (pass_kind == VELOCITY_PROJECTION_STEP_1_PASS_KIND) {\n        gl_FragColor = vec4(projection_step_1(i, j), 0, 1);\n        return;\n    }\n\n    if (pass_kind == VELOCITY_PROJECTION_STEP_2_PASS_KIND) {\n        gl_FragColor = vec4(projection_step_2(i, j), 0, 1);\n        return;\n    }\n\n    if (pass_kind == VELOCITY_PROJECTION_STEP_3_PASS_KIND) {\n        gl_FragColor = vec4(projection_step_3(i, j), density(i, j), 1);\n        return;\n    }\n\n#if DEBUG_VELOCITY\n    float grid_size = 100.0 * cell_size;\n    float hue = (degrees(atan(velocity(i, j).y, velocity(i, j).x)) + 180.0) / 360.0;\n    float value = min(length(velocity(i, j)) / grid_size, 1.0);\n    gl_FragColor = vec4(rgb_from_hsv(vec3(hue, 1, value)), 1);\n#else\n    float hue = (degrees(atan(velocity(i, j).y, velocity(i, j).x)) + 180.0) / 360.0;\n    float value = density(i, j);\n    gl_FragColor = vec4(rgb_from_hsv(vec3(hue, 1, value)), 1);\n#endif      \n}\n",(n=t||(t={}))[n.Copy=0]="Copy",n[n.DensitySource=1]="DensitySource",n[n.DensityDiffusion=2]="DensityDiffusion",n[n.DensityAdvection=3]="DensityAdvection",n[n.VelocitySource=4]="VelocitySource",n[n.VelocityDiffusion=5]="VelocityDiffusion",n[n.VelocityAdvection=6]="VelocityAdvection",n[n.VelocityProjectionStep1=7]="VelocityProjectionStep1",n[n.VelocityProjectionStep2=8]="VelocityProjectionStep2",n[n.VelocityProjectionStep3=9]="VelocityProjectionStep3",n[n.Visualization=10]="Visualization",window.addEventListener("DOMContentLoaded",function(){var n,t,r;let a=document.getElementById("demo-canvas");if(!(a instanceof HTMLCanvasElement))return console.error(`Expected a canvas element but got ${typeof a} instead.`),!1;a.width=a.clientWidth,a.height=a.clientHeight;let _=a.getContext("webgl",{alpha:!1});if(!_)return console.error("Failed to get WebGL rendering context."),!1;for(let e of["OES_texture_float","WEBGL_color_buffer_float"])if(!_.getExtension(e))return console.error(`Required WebGL extension '${e}' is unsupported.`),!1;_.viewport(0,0,_.drawingBufferWidth,_.drawingBufferHeight);let u=l(_,e(i),_.VERTEX_SHADER);if(!u)return console.error("Failed to compile vertex shader."),!1;let f=l(_,e(o),_.FRAGMENT_SHADER);if(!f)return console.error("Failed to compile fragment shader."),!1;let d=_.createProgram();if(!d)return console.error("Failed to create WebGL program."),!1;if(_.attachShader(d,u),_.attachShader(d,f),_.linkProgram(d),!_.getProgramParameter(d,_.LINK_STATUS))return console.error(`Failed to link WebGL program: ${_.getProgramInfoLog(d)}`),!1;let v={position:null,velocity:{x:0,y:0},density:0,needs_movement_processing:!1};return!function(e,n,t,i){e.useProgram(n);let o=e.createFramebuffer();if(!o)return console.error("Failed to create frame buffer."),!1;let r=e.createBuffer();if(!r)return console.error("Failed to create WebGL buffer."),!1;let[l,a,_,u]=e.getParameter(e.VIEWPORT);if(_!=u)return console.error(`Expected viewport to be square but it's ${_}x${u}.`),!1;e.uniform1i(c(e,n,"texture_0"),0),e.uniform1i(c(e,n,"texture_1"),1),e.uniform1f(c(e,n,"cell_size"),1/_),e.uniform1f(c(e,n,"dt"),1/60);let f=c(e,n,"diffusion_rate"),d=c(e,n,"dissipation_rate"),v=c(e,n,"pass_kind"),E=new Float32Array([-1,-1,-1,1,1,-1,1,-1,-1,1,1,1]);e.bindBuffer(e.ARRAY_BUFFER,r),e.bufferData(e.ARRAY_BUFFER,E,e.STATIC_DRAW);let y=function(e,n,t){let i=e.getAttribLocation(n,t);return i<0&&console.error(`Failed to get location for attribute '${t}'.`),i}(e,n,"position");e.enableVertexAttribArray(y),e.vertexAttribPointer(y,2,e.FLOAT,!1,0,0);let T=new Float32Array(_*u*4),p=s(e,_,u,T),m=s(e,_,u,T),S=s(e,_,u,T),I=s(e,_,u,T),g=s(e,_,u,T);if(!p||!m||!S||!I||!g)return console.error("Failed to initialize textures."),!1;function x(n,t,i,r){e.uniform1i(v,n),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t),e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,i),r?(e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0)):e.bindFramebuffer(e.FRAMEBUFFER,null),e.drawArrays(e.TRIANGLES,0,6)}function j(e,n){x(0,e,null,n)}function A(e,n,t){x(7,e,null,n);let o=n,r=t;for(let e=0;e<i.nr_intermediate_iterations;++e)x(8,o,null,r),[o,r]=[r,o];[o,r]=[r,o],r!=n&&j(r,n),x(9,e,n,t)}let D=m,R=S;function F(){[D,R]=[R,D]}let O=new Float32Array(1024),P=(document.getElementById("fps"),()=>{var n,o,r,l;if(j(p,I),t.position&&(t.density>0||t.needs_movement_processing)){let n=Math.max(0,t.position.x-8),i=Math.max(0,t.position.y-8),o=Math.min(_-n,16),r=Math.min(u-i,16);(function(e,n,t,i){if(1024!=e.length)return console.error("Array size doesn't match brush dimensions.");for(let o=0;o<16;++o)for(let r=0;r<16;++r){if((o-8)*(o-8)+(r-8)*(r-8)>64)continue;let l=(16*o+r)*4;e[l+0]=n,e[l+1]=t,e[l+2]=i,e[l+3]=0}})(O,t.velocity.x,t.velocity.y,t.density),e.bindTexture(e.TEXTURE_2D,I),e.texSubImage2D(e.TEXTURE_2D,0,n,i,o,r,e.RGBA,e.FLOAT,O),t.needs_movement_processing=!1}n=D,o=R,e.uniform1f(d,i.velocity_dissipation_rate),x(4,n,I,o),F(),function(n,t,o){j(n,t),e.uniform1f(f,i.velocity_diffusion_rate);let r=n,l=o;for(let e=0;e<i.nr_intermediate_iterations;++e)x(5,r,t,l),[r,l]=[l,r];[r,l]=[l,r],l!=o&&j(l,o)}(D,g,R),F(),A(D,g,R),F(),x(6,D,null,R),F(),A(D,g,R),F(),r=D,l=R,e.uniform1f(d,i.density_dissipation_rate),x(1,r,I,l),F(),function(n,t,o){j(n,t),e.uniform1f(f,i.density_diffusion_rate);let r=n,l=o;for(let e=0;e<i.nr_intermediate_iterations;++e)x(2,r,t,l),[r,l]=[l,r];[r,l]=[l,r],l!=o&&j(l,o)}(D,g,R),F(),x(3,D,null,R),x(10,R,null,null),F(),requestAnimationFrame(P)});return requestAnimationFrame(P),!0}(_,d,v,{density_diffusion_rate:1e-5,density_dissipation_rate:.01,velocity_diffusion_rate:0,velocity_dissipation_rate:1e-4,nr_intermediate_iterations:20})?(console.error("Simulation aborted."),!1):((n=a.width/2,t=a.height/2,r=a.width/10,new Promise(e=>{!function i(o){let l=2*Math.PI/30*o;v.position={x:n+Math.cos(l)*r,y:t+Math.sin(l)*r},v.velocity={x:10*Math.cos(l),y:10*Math.sin(l)},v.density=100,o+1<30?setTimeout(()=>i(o+1),33.333333333333336):(v.density=0,e())}(0)})).then(()=>(function(e,n){let t=e=>({x:e.clientX-n.offsetLeft,y:n.clientHeight-(e.clientY-n.offsetTop)});n.addEventListener("pointerdown",i=>{e.position=t(i),e.density=50,n.setPointerCapture(i.pointerId)}),n.addEventListener("pointerup",t=>{e.density=0,n.releasePointerCapture(t.pointerId)}),n.addEventListener("pointermove",n=>{let i=Object.assign(t(n),e.position);e.position=t(n),e.velocity.x=e.position.x-i.x,e.velocity.y=e.position.y-i.y,e.needs_movement_processing=!0})})(v,a)),console.log("Simulation started."),!0)},{once:!0})}();
//# sourceMappingURL=index.d09b685a.js.map
