{"mappings":"C,A,WEAA,IAAM,EAAgB,CACpB,IACA,KACA,IACA,IACA,KACA,IACA,KACA,IACA,IACA,KACA,IACA,KACD,CAEM,eAAe,EACpB,CAAiB,CACjB,CAA2B,CAC3B,CAAmD,EAanD,IAAM,EAAU,IAAI,aACd,EAAoB,EAAQ,UAAU,CAAG,EACzC,EACJ,EATmC,mBAe/B,EAAsB,AAAC,CAAA,KAC3B,IAAI,EAAuB,GAC3B,KACE,EAAuB,GACvB,GAAwB,OAExB,GAAwB,EAE1B,OAAO,CACT,CAAA,IAOM,EAAS,MAAM,UAAU,YAAY,CAAC,YAAY,CAAC,CAAE,MAAO,CAAA,CAAK,GACjE,EAAc,EAAQ,uBAAuB,CAAC,GAC9C,EAAgB,EAAQ,cAAc,EAC5C,CAAA,EAAc,OAAO,CALG,AAAsB,EAAtB,EAMxB,EAAY,OAAO,CAAC,GAGpB,IAAM,EAAuB,EAAoB,EAC3C,EAA0B,KAAK,KAAK,CAAC,AA1ChC,KA0CqC,GAC1C,EAA0B,KAAK,IAAI,CAAC,AAzC/B,KAyCoC,GAEzC,EAA4B,IAAI,WAAW,GAC3C,EAAkC,EAAE,CACpC,EAAoD,CAAC,EAgE3D,sBA9DA,SAAS,IACP,sBAAsB,GAEtB,EAAc,oBAAoB,CAAC,GAEnC,IAAI,EAAgB,EAChB,EAA0B,EAC9B,IAAK,IAAI,EAAI,EAAyB,EAAI,EAAyB,GAAK,EAClE,CAAyB,CAAC,EAAE,CAAG,IACjC,EAAgB,CAAyB,CAAC,EAAE,CAC5C,EAA0B,GAI9B,GAAI,EAAgB,EAClB,OAGF,IAAM,EACJ,AAAC,CAAA,EAA0B,EAAA,EAAO,EAE9B,EAAsB,KAAK,KAAK,CACpC,AAAqC,GAArC,KAAK,IAAI,CAAC,EAxEH,MA6EH,EACJ,EAAI,KAAK,KAAK,CAAC,AAH0B,CAAA,EAAsB,CAAA,EAGX,IAQhD,EAAgB,AADC,CAAa,CAJlC,EAAsB,GAAK,EACvB,GAAM,EAAsB,GAC5B,EAAsB,GAEwC,CAC7B,EAAgB,QAAQ,GAE/D,GAAI,EAAsB,MAAM,EAAI,EAAqB,CACvD,IAAM,EAAc,EAAsB,MAAM,CAAC,EAAG,EAAE,CAAC,EAAE,AACzD,CAAA,CAAoB,CAAC,EAAY,EAAI,CACvC,CAEA,EAAsB,IAAI,CAAC,GACrB,KAAiB,GACrB,CAAA,CAAoB,CAAC,EAAc,CAAG,CAAA,EAExC,CAAoB,CAAC,EAAc,EAAI,EAEvC,IAAI,EAAgB,GACpB,IAAK,IAAM,KAAQ,EAEf,CAAA,AAAkB,KAAlB,GACA,CAAoB,CAAC,EAAK,CAAG,CAAoB,CAAC,EAAc,AAAd,GAElD,CAAA,EAAgB,CALpB,CAQsB,CAAA,KAAlB,GACF,EAAS,EAAoB,EAEjC,EAEF,CDvHA,OAAO,gBAAgB,CAAC,mBAbxB,WACE,IAAM,EAAqB,SAAS,cAAc,CAAC,2BAC7C,EAAgB,SAAS,cAAc,CAAC,sBAE9C,GAAI,AAAuB,OAAvB,GAA+B,AAAkB,OAAlB,EACjC,MAAM,AAAI,MAAM,wBAGlB,AAAA,EAAmB,IAAK,GAAI,CAAC,EAAW,KACtC,EAAmB,WAAW,CAAG,CAAC,EAAE,KAAK,KAAK,CAAC,GAAW,EAAE,CAAC,CAC7D,EAAc,WAAW,CAAG,CAC9B,EACF,E","sources":["<anon>","projects/pitch-detection/demo.ts","projects/pitch-detection/pitch_detection.ts"],"sourcesContent":["(function () {\nconst $7be8486928707c95$var$PITCH_CLASSES = [\n    \"A\",\n    \"A#\",\n    \"B\",\n    \"C\",\n    \"C#\",\n    \"D\",\n    \"D#\",\n    \"E\",\n    \"F\",\n    \"F#\",\n    \"G\",\n    \"G#\"\n];\nasync function $7be8486928707c95$export$482f5189a7f4c24c(threshold, history_buffer_size, callback) {\n    // We want to be able to distinguish between the closest two notes in our desired range.\n    const a4 = 440;\n    const c1 = 32.7;\n    const c1_sharp = 34.65;\n    const c7 = 2093;\n    const desired_frequency_resolution = c1_sharp - c1;\n    // Determine how many frequency bins we need to achieve the desired resolution between\n    // consecutive bins. The bins denote frequencies from 0 to 1/2 of the sample rate. [1].\n    //\n    // 1. https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData\n    const context = new AudioContext();\n    const bin_max_frequency = context.sampleRate / 2;\n    const desired_frequency_bin_count = bin_max_frequency / desired_frequency_resolution;\n    // Bin count must be a power of two, so find the nearest one that satisfies our requirement.\n    // Must be between 32 and 32768. [2]\n    //\n    // 2. https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData\n    const frequency_bin_count = (()=>{\n        let nearest_power_of_two = 32;\n        while(nearest_power_of_two < desired_frequency_bin_count && nearest_power_of_two <= 32768)nearest_power_of_two *= 2;\n        return nearest_power_of_two;\n    })();\n    // The FFT window size is double the frequency bin count. [3]\n    //\n    // 3. https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/fftSize\n    const fft_window_size = frequency_bin_count * 2;\n    const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n    });\n    const source_node = context.createMediaStreamSource(stream);\n    const analyser_node = context.createAnalyser();\n    analyser_node.fftSize = fft_window_size;\n    source_node.connect(analyser_node);\n    // Determine the range of bins we are interested in based on the detection frequency range.\n    const frequency_resolution = bin_max_frequency / frequency_bin_count;\n    const detection_bin_index_min = Math.floor(c1 / frequency_resolution);\n    const detection_bin_index_max = Math.ceil(c7 / frequency_resolution);\n    const frequency_bin_intensities = new Uint8Array(frequency_bin_count);\n    const detected_note_history = [];\n    const detected_note_counts = {};\n    function process_samples() {\n        requestAnimationFrame(process_samples);\n        analyser_node.getByteFrequencyData(frequency_bin_intensities);\n        let max_intensity = 0;\n        let max_intensity_bin_index = 0;\n        for(let i = detection_bin_index_min; i < detection_bin_index_max; i += 1)if (frequency_bin_intensities[i] > max_intensity) {\n            max_intensity = frequency_bin_intensities[i];\n            max_intensity_bin_index = i;\n        }\n        if (max_intensity < threshold) return;\n        const detected_frequency = (max_intensity_bin_index + 0.5) * frequency_resolution;\n        const detected_note_index = Math.round(Math.log2(detected_frequency / a4) * 12);\n        const detected_note_index_relative_to_c4 = detected_note_index + 9;\n        const detected_octave = 4 + Math.floor(detected_note_index_relative_to_c4 / 12);\n        const detected_note_index_normalized = detected_note_index % 12 < 0 ? 12 + detected_note_index % 12 : detected_note_index % 12;\n        const detected_pitch = $7be8486928707c95$var$PITCH_CLASSES[detected_note_index_normalized];\n        const detected_note = detected_pitch + detected_octave.toString();\n        if (detected_note_history.length >= history_buffer_size) {\n            const popped_note = detected_note_history.splice(0, 1)[0];\n            detected_note_counts[popped_note] -= 1;\n        }\n        detected_note_history.push(detected_note);\n        if (!(detected_note in detected_note_counts)) detected_note_counts[detected_note] = 0;\n        detected_note_counts[detected_note] += 1;\n        let dominant_note = \"\";\n        for(const note in detected_note_counts)if (dominant_note === \"\" || detected_note_counts[note] > detected_note_counts[dominant_note]) dominant_note = note;\n        if (dominant_note !== \"\") callback(detected_frequency, dominant_note);\n    }\n    requestAnimationFrame(process_samples);\n}\n\n\nfunction $5119fa161649b5f5$var$setup() {\n    const detected_frequency = document.getElementById(\"demo-detected-frequency\");\n    const detected_note = document.getElementById(\"demo-detected-note\");\n    if (detected_frequency === null || detected_note === null) throw new Error(\"missing demo element\");\n    (0, $7be8486928707c95$export$482f5189a7f4c24c)(125, 12, (frequency, note)=>{\n        detected_frequency.textContent = `${Math.round(frequency)}Hz`;\n        detected_note.textContent = note;\n    });\n}\nwindow.addEventListener(\"DOMContentLoaded\", $5119fa161649b5f5$var$setup);\n\n})();\n//# sourceMappingURL=index.7a964e62.js.map\n","import { detect_from_device } from \"./pitch_detection\";\r\n\r\nfunction setup() {\r\n  const detected_frequency = document.getElementById(\"demo-detected-frequency\");\r\n  const detected_note = document.getElementById(\"demo-detected-note\");\r\n\r\n  if (detected_frequency === null || detected_note === null) {\r\n    throw new Error(\"missing demo element\");\r\n  }\r\n\r\n  detect_from_device(125, 12, (frequency, note) => {\r\n    detected_frequency.textContent = `${Math.round(frequency)}Hz`;\r\n    detected_note.textContent = note;\r\n  });\r\n}\r\nwindow.addEventListener(\"DOMContentLoaded\", setup);\r\n","const PITCH_CLASSES = [\r\n  \"A\",\r\n  \"A#\",\r\n  \"B\",\r\n  \"C\",\r\n  \"C#\",\r\n  \"D\",\r\n  \"D#\",\r\n  \"E\",\r\n  \"F\",\r\n  \"F#\",\r\n  \"G\",\r\n  \"G#\",\r\n] as const;\r\n\r\nexport async function detect_from_device(\r\n  threshold: number,\r\n  history_buffer_size: number,\r\n  callback: (frequency: number, note: string) => void\r\n) {\r\n  // We want to be able to distinguish between the closest two notes in our desired range.\r\n  const a4 = 440;\r\n  const c1 = 32.7;\r\n  const c1_sharp = 34.65;\r\n  const c7 = 2093;\r\n  const desired_frequency_resolution = c1_sharp - c1;\r\n\r\n  // Determine how many frequency bins we need to achieve the desired resolution between\r\n  // consecutive bins. The bins denote frequencies from 0 to 1/2 of the sample rate. [1].\r\n  //\r\n  // 1. https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData\r\n  const context = new AudioContext();\r\n  const bin_max_frequency = context.sampleRate / 2;\r\n  const desired_frequency_bin_count =\r\n    bin_max_frequency / desired_frequency_resolution;\r\n\r\n  // Bin count must be a power of two, so find the nearest one that satisfies our requirement.\r\n  // Must be between 32 and 32768. [2]\r\n  //\r\n  // 2. https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData\r\n  const frequency_bin_count = (() => {\r\n    let nearest_power_of_two = 32;\r\n    while (\r\n      nearest_power_of_two < desired_frequency_bin_count &&\r\n      nearest_power_of_two <= 32768\r\n    ) {\r\n      nearest_power_of_two *= 2;\r\n    }\r\n    return nearest_power_of_two;\r\n  })();\r\n\r\n  // The FFT window size is double the frequency bin count. [3]\r\n  //\r\n  // 3. https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/fftSize\r\n  const fft_window_size = frequency_bin_count * 2;\r\n\r\n  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n  const source_node = context.createMediaStreamSource(stream);\r\n  const analyser_node = context.createAnalyser();\r\n  analyser_node.fftSize = fft_window_size;\r\n  source_node.connect(analyser_node);\r\n\r\n  // Determine the range of bins we are interested in based on the detection frequency range.\r\n  const frequency_resolution = bin_max_frequency / frequency_bin_count;\r\n  const detection_bin_index_min = Math.floor(c1 / frequency_resolution);\r\n  const detection_bin_index_max = Math.ceil(c7 / frequency_resolution);\r\n\r\n  const frequency_bin_intensities = new Uint8Array(frequency_bin_count);\r\n  const detected_note_history: string[] = [];\r\n  const detected_note_counts: { [index: string]: number } = {};\r\n\r\n  function process_samples() {\r\n    requestAnimationFrame(process_samples);\r\n\r\n    analyser_node.getByteFrequencyData(frequency_bin_intensities);\r\n\r\n    let max_intensity = 0;\r\n    let max_intensity_bin_index = 0;\r\n    for (let i = detection_bin_index_min; i < detection_bin_index_max; i += 1) {\r\n      if (frequency_bin_intensities[i] > max_intensity) {\r\n        max_intensity = frequency_bin_intensities[i];\r\n        max_intensity_bin_index = i;\r\n      }\r\n    }\r\n\r\n    if (max_intensity < threshold) {\r\n      return;\r\n    }\r\n\r\n    const detected_frequency =\r\n      (max_intensity_bin_index + 0.5) * frequency_resolution;\r\n\r\n    const detected_note_index = Math.round(\r\n      Math.log2(detected_frequency / a4) * 12\r\n    );\r\n\r\n    const detected_note_index_relative_to_c4 = detected_note_index + 9;\r\n\r\n    const detected_octave =\r\n      4 + Math.floor(detected_note_index_relative_to_c4 / 12);\r\n\r\n    const detected_note_index_normalized =\r\n      detected_note_index % 12 < 0\r\n        ? 12 + (detected_note_index % 12)\r\n        : detected_note_index % 12;\r\n\r\n    const detected_pitch = PITCH_CLASSES[detected_note_index_normalized];\r\n    const detected_note = detected_pitch + detected_octave.toString();\r\n\r\n    if (detected_note_history.length >= history_buffer_size) {\r\n      const popped_note = detected_note_history.splice(0, 1)[0];\r\n      detected_note_counts[popped_note] -= 1;\r\n    }\r\n\r\n    detected_note_history.push(detected_note);\r\n    if (!(detected_note in detected_note_counts)) {\r\n      detected_note_counts[detected_note] = 0;\r\n    }\r\n    detected_note_counts[detected_note] += 1;\r\n\r\n    let dominant_note = \"\";\r\n    for (const note in detected_note_counts) {\r\n      if (\r\n        dominant_note === \"\" ||\r\n        detected_note_counts[note] > detected_note_counts[dominant_note]\r\n      ) {\r\n        dominant_note = note;\r\n      }\r\n    }\r\n    if (dominant_note !== \"\") {\r\n      callback(detected_frequency, dominant_note);\r\n    }\r\n  }\r\n  requestAnimationFrame(process_samples);\r\n}\r\n"],"names":["$7be8486928707c95$var$PITCH_CLASSES","$7be8486928707c95$export$482f5189a7f4c24c","threshold","history_buffer_size","callback","context","AudioContext","bin_max_frequency","sampleRate","desired_frequency_bin_count","c1_sharp","frequency_bin_count","nearest_power_of_two","stream","navigator","mediaDevices","getUserMedia","audio","source_node","createMediaStreamSource","analyser_node","createAnalyser","fftSize","connect","frequency_resolution","detection_bin_index_min","Math","floor","c1","detection_bin_index_max","ceil","c7","frequency_bin_intensities","Uint8Array","detected_note_history","detected_note_counts","requestAnimationFrame","process_samples","getByteFrequencyData","max_intensity","max_intensity_bin_index","i","detected_frequency","detected_note_index","round","log2","detected_octave","detected_note_index_relative_to_c4","detected_note","detected_pitch","toString","length","popped_note","splice","push","dominant_note","note","window","addEventListener","document","getElementById","Error","frequency","textContent"],"version":3,"file":"index.7a964e62.js.map"}