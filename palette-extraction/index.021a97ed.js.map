{"mappings":"C,A,WEGA,SAAS,EAAwB,CAAW,CAAE,CAAW,EACvD,OAAO,EAAM,KAAK,KAAK,CAAC,KAAK,MAAM,GAAM,CAAA,EAAM,EAAM,CAAA,EACvD,CDgDA,OAAO,gBAAgB,CAAC,mBAbxB,WACE,IAAM,EAAa,SAAS,cAAc,CAAC,cACrC,aAAsB,mBAG5B,EAAW,gBAAgB,CAAC,SAAU,IACpC,AA5CJ,CAAA,SAAkC,CAA4B,EAC5D,GAAI,AAAqB,OAArB,EAAW,KAAK,EAAa,AAA4B,IAA5B,EAAW,KAAK,CAAC,MAAM,CACtD,OAEF,IAAM,EAAO,EAAW,KAAK,CAAC,IAAI,CAAC,GACnC,GAAI,AAAS,OAAT,EACF,OAEF,IAAM,EAAQ,IAAI,KAClB,CAAA,EAAM,GAAG,CAAG,IAAI,eAAe,CAAC,GAChC,EAAM,gBAAgB,CAAC,OAAQ,KAC7B,IAAM,EAAiB,SAAS,gBAAgB,CAC9C,uBAEI,EAAe,EAAe,MAAM,CACpC,EAAqB,KAAK,IAAI,CAClC,KAAK,GAAG,CAAC,EAAM,YAAY,CAAE,EAAM,aAAa,EAAI,IAEhD,EAAU,AC6Cb,CAAA,SACL,CAAuB,CACvB,CAA0B,CAC1B,CAAoB,EAEpB,IAAM,EAAS,SAAS,aAAa,CAAC,SACtC,CAAA,EAAO,KAAK,CAAG,EAAM,YAAY,CACjC,EAAO,MAAM,CAAG,EAAM,aAAa,CAEnC,IAAM,EAAU,EAAO,UAAU,CAAC,MAClC,GAAI,AAAY,OAAZ,EACF,MAAM,AAAI,MAAM,6BAKlB,OAFA,EAAQ,SAAS,CAAC,EAAO,EAAG,EAAG,EAAO,KAAK,CAAE,EAAO,MAAM,EAEnD,AA1EF,SACL,CAAqB,CACrB,CAA0B,CAC1B,CAAoB,EAGpB,IAAM,EAAuB,EAAE,CAC/B,IACE,IAAI,EAAQ,EACZ,EAAQ,EAAW,KAAK,CAAG,EAC3B,GAAS,EAET,IACE,IAAI,EAAQ,EACZ,EAAQ,EAAW,MAAM,CAAG,EAC5B,GAAS,EACT,CACA,IAEM,EAAe,EAAK,CAAA,AAFhB,EAAwB,EAAO,EAAQ,GAEnB,AADpB,EAAwB,EAAO,EAAQ,GACf,EAAW,KAAK,AAAL,EACvC,EAAe,EAAW,IAAI,CAAC,KAAK,CACxC,EACA,EAAe,GAEjB,EAAY,IAAI,CAAC,CAAC,CAAY,CAAC,EAAE,CAAE,CAAY,CAAC,EAAE,CAAE,CAAY,CAAC,EAAE,CAAC,CACtE,CAGF,IAAM,EAAuB,EAAY,GAAG,CAAC,AAAC,GAC5C,AC9BG,CAAA,SAAsB,CAAS,CAAE,CAAS,CAAE,CAAS,EAK1D,IAAM,EAAM,KAAK,GAAG,CAJpB,GAAK,IACL,GAAK,IACL,GAAK,KAGC,EAAM,KAAK,GAAG,CAAC,EAAG,EAAG,GAEvB,EAAI,EACJ,EAAI,EACJ,EAAI,AAAC,CAAA,EAAM,CAAA,EAAO,EAEtB,GAAI,IAAQ,EACV,EAAI,EACJ,EAAI,MAED,CACH,IAAM,EAAO,EAAM,EAEnB,OADA,EAAI,EAAI,GAAM,EAAQ,CAAA,EAAI,EAAM,CAAA,EAAO,EAAQ,CAAA,EAAM,CAAA,EAC7C,GACN,KAAK,EACH,EAAI,AAAC,CAAA,EAAI,CAAA,EAAK,EAAQ,CAAA,EAAI,EAAI,EAAI,CAAA,EAClC,KACF,MAAK,EACH,EAAK,AAAA,CAAA,EAAI,CAAA,EAAK,EAAO,EACrB,KACF,MAAK,EACH,EAAK,AAAA,CAAA,EAAI,CAAA,EAAK,EAAO,CAEzB,CACA,GAAK,CACP,CACA,MAAO,CAAC,EAAG,EAAG,EAAE,AAClB,CAAA,EDHiB,CAAK,CAAC,EAAE,CAAE,CAAK,CAAC,EAAE,CAAE,CAAK,CAAC,EAAE,GAGrC,EAAkC,EAAE,CAC1C,IAAK,IAAI,EAAI,EAAG,EAAI,EAAc,GAAK,EAAG,CACxC,IAAM,EAAe,EAAwB,EAAG,EAAY,MAAM,CAAG,GACrE,EAAuB,IAAI,CAAC,CAAW,CAAC,EAAa,CACvD,CAUA,MAAO,AE9CF,CAAA,SACL,CAAiB,CACjB,CAAqB,CACrB,CAAuB,CACvB,CAA0C,EAE1C,IAAM,EAZC,KAAK,KAAK,CAAC,KAAK,SAAS,CAYJ,IACxB,EAA8B,AAAI,MAAM,EAAQ,MAAM,EAAE,IAAI,CAAC,IAC7D,EAAyB,AAAI,MAAM,GAAe,IAAI,CAAC,GACvD,EAAmB,CAAA,EAEvB,KAAO,GACL,EAAa,IAAI,CAAC,GAClB,EAAmB,CAAA,EAGnB,EAAQ,OAAO,CAAC,CAAC,EAAQ,KACvB,IAAI,EAA6B,EAC7B,EAAgC,EAAS,EAAQ,CAAa,CAAC,EAAE,EACrE,IAAK,IAAI,EAAI,EAAG,EAAI,EAAe,EAAE,EAAG,CACtC,IAAM,EAA6B,EAAS,EAAQ,CAAa,CAAC,EAAE,EAChE,EAA6B,IAC/B,EAAgC,EAChC,EAA6B,EAEjC,CAGE,CAAA,AAAoC,KAApC,CAAiB,CAAC,EAAa,EAC/B,CAAiB,CAAC,EAAa,GAAK,CAAA,GAEpC,CAAA,EAAmB,CAAA,CAJrB,EAOA,CAAiB,CAAC,EAAa,CAAG,EAClC,CAAY,CAAC,EAA2B,EAAI,CAC9C,GAGI,IACF,EAAc,OAAO,CAAC,AAAC,GAAS,EAAK,IAAI,CAAC,IAC1C,EAAQ,OAAO,CAAC,CAAC,EAAQ,KACvB,IAAM,EAAuB,CAAiB,CAAC,EAAa,CACtD,EAAsB,CAAY,CAAC,EAAqB,CACxD,EAAe,CAAa,CAAC,EAAqB,CACxD,EAAa,OAAO,CAClB,CAAC,EAAG,IAAO,CAAY,CAAC,EAAE,EAAI,CAAM,CAAC,EAAE,CAAG,EAE9C,IAIJ,OAAO,EACJ,GAAG,CAAC,CAAC,EAAM,IACH,CAAA,CACL,KAAA,EACA,KAAM,CAAY,CAAC,EAAM,AAC3B,CAAA,GAED,MAAM,CAAC,AAAC,GAAY,EAAQ,IAAI,CAAG,EACxC,CAAA,EFbI,EACA,EACA,EAXF,SAAsB,CAAS,CAAE,CAAS,EACxC,MACG,AAAA,CAAA,CAAC,CAAC,EAAE,CAAG,CAAC,CAAC,EAAE,AAAF,EAAO,CAAA,CAAC,CAAC,EAAE,CAAG,CAAC,CAAC,EAAE,AAAF,EAC1B,AAAC,CAAA,CAAC,CAAC,EAAE,CAAG,CAAC,CAAC,EAAC,AAAD,EAAO,CAAA,CAAC,CAAC,EAAE,CAAG,CAAC,CAAC,EAAC,AAAD,EACzB,AAAA,CAAA,CAAC,CAAC,EAAE,CAAG,CAAC,CAAC,EAAE,AAAF,EAAO,CAAA,CAAC,CAAC,EAAE,CAAG,CAAC,CAAC,EAAE,AAAF,CAE9B,GAQG,IAAI,CAAC,CAAC,EAAG,IAAM,EAAE,IAAI,CAAG,EAAE,IAAI,EAC9B,GAAG,CAAC,AAAC,GACJ,AChBC,CAAA,SAAsB,CAAS,CAAE,CAAS,CAAE,CAAS,EAC1D,SAAS,EAAa,CAAS,CAAE,CAAS,CAAE,CAAS,QAGnD,CAFI,EAAI,GAAG,CAAA,GAAK,CAAA,EACZ,EAAI,GAAG,CAAA,GAAK,CAAA,EACZ,EAAI,EAAI,GAAU,EAAI,AAAC,CAAA,EAAI,CAAA,EAAK,EAAI,EACpC,EAAI,GAAc,EAClB,EAAI,EAAI,EAAU,EAAI,AAAC,CAAA,EAAI,CAAA,EAAM,CAAA,EAAI,EAAI,CAAA,EAAK,EAC3C,CACT,CAEA,IAAI,EAAI,EACJ,EAAI,EACJ,EAAI,EAER,GAAI,AAAM,IAAN,EACF,EAAI,EACJ,EAAI,EACJ,EAAI,MAED,CACH,IAAM,EAAI,EAAI,GAAM,EAAK,CAAA,EAAI,CAAA,EAAK,EAAI,EAAI,EAAI,EACxC,EAAI,EAAI,EAAI,EAClB,EAAI,EAAa,EAAG,EAAG,EAAI,EAAI,GAC/B,EAAI,EAAa,EAAG,EAAG,GACvB,EAAI,EAAa,EAAG,EAAG,EAAI,EAAI,EACjC,CACA,MAAO,CACL,KAAK,GAAG,CAAC,KAAK,GAAG,CAAC,AAAI,IAAJ,EAAS,KAAM,GACjC,KAAK,GAAG,CAAC,KAAK,GAAG,CAAC,AAAI,IAAJ,EAAS,KAAM,GACjC,KAAK,GAAG,CAAC,KAAK,GAAG,CAAC,AAAI,IAAJ,EAAS,KAAM,GAClC,AACH,CAAA,EDfmB,EAAQ,IAAI,CAAC,EAAE,CAAE,EAAQ,IAAI,CAAC,EAAE,CAAE,EAAQ,IAAI,CAAC,EAAE,EAEpE,EAiBqB,EAAQ,YAAY,CAAC,EAAG,EAAG,EAAO,KAAK,CAAE,EAAO,MAAM,EAC9B,EAAoB,EACjE,CAAA,ED7DM,EACA,EACA,GACA,GAAG,CAAC,AAAC,GAAU,EAAM,GAAG,CAAC,KAAK,KAAK,GACrC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAe,MAAM,CAAE,GAAK,EAC9C,EAAe,IAAI,CAAC,GAAG,KAAK,CAAC,cAAc,CAAC,oBAE9C,IAAK,IAAI,EAAI,EAAG,EAAI,EAAQ,MAAM,CAAE,GAAK,EAAG,CAC1C,IAAM,EAAQ,CAAO,CAAC,EAAE,CAClB,EAAU,EAAe,IAAI,CAAC,EACpC,CAAA,EAAQ,KAAK,CAAC,eAAe,CAAG,CAAC,IAAI,EAAE,CAAK,CAAC,EAAE,CAAC,EAAE,EAAE,CAAK,CAAC,EAAE,CAAC,EAAE,EAAE,CAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAC5E,EAAQ,YAAY,CAClB,aACA,CAAC,oBAAoB,EAAE,CAAK,CAAC,EAAE,CAAC,EAAE,EAAE,CAAK,CAAC,EAAE,CAAC,EAAE,EAAE,CAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAEhE,CACF,EACF,CAAA,EAQ6B,IAE3B,SACG,cAAc,CAAC,6BACd,iBAAiB,QAAS,IAAM,EAAW,KAAK,IACtD,E","sources":["<anon>","projects/palette-extraction/demo.ts","projects/palette-extraction/image_palette_extraction.ts","projects/palette-extraction/color_conversion.ts","projects/palette-extraction/k_means_clustering.ts"],"sourcesContent":["(function () {\nfunction $5c5f43425d79cb95$export$69d5a0bee28624af(r, g, b) {\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    let h = 0;\n    let s = 0;\n    let l = (max + min) / 2;\n    if (max === min) {\n        h = 0;\n        s = 0;\n    } else {\n        const span = max - min;\n        s = l > 0.5 ? span / (2 - max - min) : span / (max + min);\n        switch(max){\n            case r:\n                h = (g - b) / span + (g < b ? 6 : 0);\n                break;\n            case g:\n                h = (b - r) / span + 2;\n                break;\n            case b:\n                h = (r - g) / span + 4;\n                break;\n        }\n        h /= 6;\n    }\n    return [\n        h,\n        s,\n        l\n    ];\n}\nfunction $5c5f43425d79cb95$export$b973f735a0b1be26(h, s, l) {\n    function rgb_from_hue(p, q, t) {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 0.5) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n    }\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    if (s === 0) {\n        r = l;\n        g = l;\n        b = l;\n    } else {\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        r = rgb_from_hue(p, q, h + 1 / 3);\n        g = rgb_from_hue(p, q, h);\n        b = rgb_from_hue(p, q, h - 1 / 3);\n    }\n    return [\n        Math.max(Math.min(r * 256, 255), 0),\n        Math.max(Math.min(g * 256, 255), 0),\n        Math.max(Math.min(b * 256, 255), 0)\n    ];\n}\n\n\nfunction $8505916ec69c1f4d$var$clone(value) {\n    return JSON.parse(JSON.stringify(value));\n}\nfunction $8505916ec69c1f4d$export$1010be256a6932bb(samples, cluster_count, initial_guess, distance) {\n    const cluster_means = $8505916ec69c1f4d$var$clone(initial_guess);\n    let cluster_of_sample = new Array(samples.length).fill(-1);\n    let cluster_size = new Array(cluster_count).fill(0);\n    let clusters_changed = true;\n    while(clusters_changed){\n        cluster_size.fill(0);\n        clusters_changed = false;\n        // Associate each sample with its nearest cluster mean.\n        samples.forEach((sample, sample_index)=>{\n            let nearest_cluster_mean_index = 0;\n            let nearest_cluster_mean_distance = distance(sample, cluster_means[0]);\n            for(let i = 1; i < cluster_count; ++i){\n                const distance_to_cluster_mean_i = distance(sample, cluster_means[i]);\n                if (distance_to_cluster_mean_i < nearest_cluster_mean_distance) {\n                    nearest_cluster_mean_distance = distance_to_cluster_mean_i;\n                    nearest_cluster_mean_index = i;\n                }\n            }\n            if (cluster_of_sample[sample_index] === -1 || cluster_of_sample[sample_index] !== nearest_cluster_mean_index) clusters_changed = true;\n            cluster_of_sample[sample_index] = nearest_cluster_mean_index;\n            cluster_size[nearest_cluster_mean_index] += 1;\n        });\n        // Recompute the means.\n        if (clusters_changed) {\n            cluster_means.forEach((mean)=>mean.fill(0));\n            samples.forEach((sample, sample_index)=>{\n                const sample_cluster_index = cluster_of_sample[sample_index];\n                const sample_cluster_size = cluster_size[sample_cluster_index];\n                const cluster_mean = cluster_means[sample_cluster_index];\n                cluster_mean.forEach((_, i)=>cluster_mean[i] += sample[i] / sample_cluster_size);\n            });\n        }\n    }\n    return cluster_means.map((mean, index)=>{\n        return {\n            mean: mean,\n            size: cluster_size[index]\n        };\n    }).filter((cluster)=>cluster.size > 0);\n}\n\n\nfunction $3cd1e6270ef4e68d$var$random_integer_in_range(min, max) {\n    return min + Math.floor(Math.random() * (max - min + 1));\n}\nfunction $3cd1e6270ef4e68d$export$85a4233b636598d(image_data, sampling_cell_size, palette_size) {\n    // Collect color observations using jittered-grid super sampling.\n    const samples_rgb = [];\n    for(let x_min = 0; x_min < image_data.width - sampling_cell_size; x_min += sampling_cell_size)for(let y_min = 0; y_min < image_data.height - sampling_cell_size; y_min += sampling_cell_size){\n        const x = $3cd1e6270ef4e68d$var$random_integer_in_range(x_min, x_min + sampling_cell_size);\n        const y = $3cd1e6270ef4e68d$var$random_integer_in_range(y_min, y_min + sampling_cell_size);\n        const sample_index = 4 * (x + y * image_data.width);\n        const sample_slice = image_data.data.slice(sample_index, sample_index + 3);\n        samples_rgb.push([\n            sample_slice[0],\n            sample_slice[1],\n            sample_slice[2]\n        ]);\n    }\n    const samples_hsl = samples_rgb.map((color)=>(0, $5c5f43425d79cb95$export$69d5a0bee28624af)(color[0], color[1], color[2]));\n    const clusters_initial_guess = [];\n    for(let i = 0; i < palette_size; i += 1){\n        const random_index = $3cd1e6270ef4e68d$var$random_integer_in_range(0, samples_hsl.length - 1);\n        clusters_initial_guess.push(samples_hsl[random_index]);\n    }\n    function hsl_distance(a, b) {\n        return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]) + (a[2] - b[2]) * (a[2] - b[2]);\n    }\n    return (0, $8505916ec69c1f4d$export$1010be256a6932bb)(samples_hsl, palette_size, clusters_initial_guess, hsl_distance).sort((a, b)=>b.size - a.size).map((cluster)=>(0, $5c5f43425d79cb95$export$b973f735a0b1be26)(cluster.mean[0], cluster.mean[1], cluster.mean[2]));\n}\nfunction $3cd1e6270ef4e68d$export$1059ec8f4511ea27(image, sampling_cell_size, palette_size) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = image.naturalWidth;\n    canvas.height = image.naturalHeight;\n    const context = canvas.getContext(\"2d\");\n    if (context === null) throw new Error(\"cannot get canvas context\");\n    context.drawImage(image, 0, 0, canvas.width, canvas.height);\n    const image_data = context.getImageData(0, 0, canvas.width, canvas.height);\n    return $3cd1e6270ef4e68d$export$85a4233b636598d(image_data, sampling_cell_size, palette_size);\n}\n\n\nfunction $7ca515745310f523$var$on_selected_image_change(file_input) {\n    if (file_input.files === null || file_input.files.length !== 1) return;\n    const file = file_input.files.item(0);\n    if (file === null) return;\n    const image = new Image();\n    image.src = URL.createObjectURL(file);\n    image.addEventListener(\"load\", ()=>{\n        const color_elements = document.querySelectorAll(\".demo-palette-color\");\n        const palette_size = color_elements.length;\n        const sampling_cell_size = Math.ceil(Math.min(image.naturalWidth, image.naturalHeight) / 20);\n        const palette = (0, $3cd1e6270ef4e68d$export$1059ec8f4511ea27)(image, sampling_cell_size, palette_size).map((color)=>color.map(Math.round));\n        for(let i = 0; i < color_elements.length; i += 1)color_elements.item(i).style.removeProperty(\"background-color\");\n        for(let i = 0; i < palette.length; i += 1){\n            const color = palette[i];\n            const element = color_elements.item(i);\n            element.style.backgroundColor = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;\n            element.setAttribute(\"aria-label\", `Colored square: rgb(${color[0]}, ${color[1]}, ${color[2]})`);\n        }\n    });\n}\nfunction $7ca515745310f523$var$setup() {\n    const file_input = document.getElementById(\"demo-image\");\n    if (!(file_input instanceof HTMLInputElement)) return;\n    file_input.addEventListener(\"change\", ()=>$7ca515745310f523$var$on_selected_image_change(file_input));\n    document.getElementById(\"demo-select-image-button\")?.addEventListener(\"click\", ()=>file_input.click());\n}\nwindow.addEventListener(\"DOMContentLoaded\", $7ca515745310f523$var$setup);\n\n})();\n//# sourceMappingURL=index.021a97ed.js.map\n","import { palette_from_image_element } from \"./image_palette_extraction\";\r\n\r\nfunction on_selected_image_change(file_input: HTMLInputElement) {\r\n  if (file_input.files === null || file_input.files.length !== 1) {\r\n    return;\r\n  }\r\n  const file = file_input.files.item(0);\r\n  if (file === null) {\r\n    return;\r\n  }\r\n  const image = new Image();\r\n  image.src = URL.createObjectURL(file);\r\n  image.addEventListener(\"load\", () => {\r\n    const color_elements = document.querySelectorAll<HTMLElement>(\r\n      \".demo-palette-color\"\r\n    );\r\n    const palette_size = color_elements.length;\r\n    const sampling_cell_size = Math.ceil(\r\n      Math.min(image.naturalWidth, image.naturalHeight) / 20\r\n    );\r\n    const palette = palette_from_image_element(\r\n      image,\r\n      sampling_cell_size,\r\n      palette_size\r\n    ).map((color) => color.map(Math.round));\r\n    for (let i = 0; i < color_elements.length; i += 1) {\r\n      color_elements.item(i).style.removeProperty(\"background-color\");\r\n    }\r\n    for (let i = 0; i < palette.length; i += 1) {\r\n      const color = palette[i];\r\n      const element = color_elements.item(i);\r\n      element.style.backgroundColor = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;\r\n      element.setAttribute(\r\n        \"aria-label\",\r\n        `Colored square: rgb(${color[0]}, ${color[1]}, ${color[2]})`\r\n      );\r\n    }\r\n  });\r\n}\r\n\r\nfunction setup() {\r\n  const file_input = document.getElementById(\"demo-image\");\r\n  if (!(file_input instanceof HTMLInputElement)) {\r\n    return;\r\n  }\r\n  file_input.addEventListener(\"change\", () =>\r\n    on_selected_image_change(file_input)\r\n  );\r\n  document\r\n    .getElementById(\"demo-select-image-button\")\r\n    ?.addEventListener(\"click\", () => file_input.click());\r\n}\r\n\r\nwindow.addEventListener(\"DOMContentLoaded\", setup);\r\n","import { Color, hsl_from_rgb, rgb_from_hsl } from \"./color_conversion\";\r\nimport { k_means_clusters, Sample } from \"./k_means_clustering\";\r\n\r\nfunction random_integer_in_range(min: number, max: number): number {\r\n  return min + Math.floor(Math.random() * (max - min + 1));\r\n}\r\n\r\nexport function palette_from_image_data(\r\n  image_data: ImageData,\r\n  sampling_cell_size: number,\r\n  palette_size: number\r\n): Color[] {\r\n  // Collect color observations using jittered-grid super sampling.\r\n  const samples_rgb: Color[] = [];\r\n  for (\r\n    let x_min = 0;\r\n    x_min < image_data.width - sampling_cell_size;\r\n    x_min += sampling_cell_size\r\n  ) {\r\n    for (\r\n      let y_min = 0;\r\n      y_min < image_data.height - sampling_cell_size;\r\n      y_min += sampling_cell_size\r\n    ) {\r\n      const x = random_integer_in_range(x_min, x_min + sampling_cell_size);\r\n      const y = random_integer_in_range(y_min, y_min + sampling_cell_size);\r\n      const sample_index = 4 * (x + y * image_data.width);\r\n      const sample_slice = image_data.data.slice(\r\n        sample_index,\r\n        sample_index + 3\r\n      );\r\n      samples_rgb.push([sample_slice[0], sample_slice[1], sample_slice[2]]);\r\n    }\r\n  }\r\n\r\n  const samples_hsl: Color[] = samples_rgb.map((color) =>\r\n    hsl_from_rgb(color[0], color[1], color[2])\r\n  );\r\n\r\n  const clusters_initial_guess: Color[] = [];\r\n  for (let i = 0; i < palette_size; i += 1) {\r\n    const random_index = random_integer_in_range(0, samples_hsl.length - 1);\r\n    clusters_initial_guess.push(samples_hsl[random_index]);\r\n  }\r\n\r\n  function hsl_distance(a: Sample, b: Sample): number {\r\n    return (\r\n      (a[0] - b[0]) * (a[0] - b[0]) +\r\n      (a[1] - b[1]) * (a[1] - b[1]) +\r\n      (a[2] - b[2]) * (a[2] - b[2])\r\n    );\r\n  }\r\n\r\n  return k_means_clusters(\r\n    samples_hsl,\r\n    palette_size,\r\n    clusters_initial_guess,\r\n    hsl_distance\r\n  )\r\n    .sort((a, b) => b.size - a.size)\r\n    .map((cluster) =>\r\n      rgb_from_hsl(cluster.mean[0], cluster.mean[1], cluster.mean[2])\r\n    );\r\n}\r\n\r\nexport function palette_from_image_element(\r\n  image: HTMLImageElement,\r\n  sampling_cell_size: number,\r\n  palette_size: number\r\n): Color[] {\r\n  const canvas = document.createElement(\"canvas\");\r\n  canvas.width = image.naturalWidth;\r\n  canvas.height = image.naturalHeight;\r\n\r\n  const context = canvas.getContext(\"2d\");\r\n  if (context === null) {\r\n    throw new Error(\"cannot get canvas context\");\r\n  }\r\n\r\n  context.drawImage(image, 0, 0, canvas.width, canvas.height);\r\n  const image_data = context.getImageData(0, 0, canvas.width, canvas.height);\r\n  return palette_from_image_data(image_data, sampling_cell_size, palette_size);\r\n}\r\n","export type Color = [number, number, number];\r\n\r\n// Generates triplet [h, s, l] with members in [0, 1] from triplet r, g, b with members\r\n// in [0, 255].\r\n//\r\n// Adapted from https://gist.github.com/mjackson/5311256\r\nexport function hsl_from_rgb(r: number, g: number, b: number): Color {\r\n  r /= 255;\r\n  g /= 255;\r\n  b /= 255;\r\n\r\n  const max = Math.max(r, g, b);\r\n  const min = Math.min(r, g, b);\r\n\r\n  let h = 0;\r\n  let s = 0;\r\n  let l = (max + min) / 2;\r\n\r\n  if (max === min) {\r\n    h = 0;\r\n    s = 0;\r\n  } // achromatic\r\n  else {\r\n    const span = max - min;\r\n    s = l > 0.5 ? span / (2 - max - min) : span / (max + min);\r\n    switch (max) {\r\n      case r:\r\n        h = (g - b) / span + (g < b ? 6 : 0);\r\n        break;\r\n      case g:\r\n        h = (b - r) / span + 2;\r\n        break;\r\n      case b:\r\n        h = (r - g) / span + 4;\r\n        break;\r\n    }\r\n    h /= 6;\r\n  }\r\n  return [h, s, l];\r\n}\r\n\r\n// Generates triplet [r, g, b] with members in [0, 255] from triplet h, s, l with members\r\n// in [0, 1].\r\n//\r\n// Adapted from https://gist.github.com/mjackson/5311256\r\nexport function rgb_from_hsl(h: number, s: number, l: number): Color {\r\n  function rgb_from_hue(p: number, q: number, t: number) {\r\n    if (t < 0) t += 1;\r\n    if (t > 1) t -= 1;\r\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\r\n    if (t < 1 / 2) return q;\r\n    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\r\n    return p;\r\n  }\r\n\r\n  let r = 0;\r\n  let g = 0;\r\n  let b = 0;\r\n\r\n  if (s === 0) {\r\n    r = l;\r\n    g = l;\r\n    b = l;\r\n  } // achromatic\r\n  else {\r\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\r\n    const p = 2 * l - q;\r\n    r = rgb_from_hue(p, q, h + 1 / 3);\r\n    g = rgb_from_hue(p, q, h);\r\n    b = rgb_from_hue(p, q, h - 1 / 3);\r\n  }\r\n  return [\r\n    Math.max(Math.min(r * 256, 255), 0),\r\n    Math.max(Math.min(g * 256, 255), 0),\r\n    Math.max(Math.min(b * 256, 255), 0),\r\n  ];\r\n}\r\n","function clone<T>(value: T): T {\r\n  return JSON.parse(JSON.stringify(value));\r\n}\r\n\r\nexport type Sample = number[];\r\nexport type Cluster = { mean: Sample; size: number };\r\n\r\nexport function k_means_clusters(\r\n  samples: Sample[],\r\n  cluster_count: number,\r\n  initial_guess: Sample[],\r\n  distance: (a: Sample, b: Sample) => number\r\n): Cluster[] {\r\n  const cluster_means = clone(initial_guess);\r\n  let cluster_of_sample: number[] = new Array(samples.length).fill(-1);\r\n  let cluster_size: number[] = new Array(cluster_count).fill(0);\r\n  let clusters_changed = true;\r\n\r\n  while (clusters_changed) {\r\n    cluster_size.fill(0);\r\n    clusters_changed = false;\r\n\r\n    // Associate each sample with its nearest cluster mean.\r\n    samples.forEach((sample, sample_index) => {\r\n      let nearest_cluster_mean_index = 0;\r\n      let nearest_cluster_mean_distance = distance(sample, cluster_means[0]);\r\n      for (let i = 1; i < cluster_count; ++i) {\r\n        const distance_to_cluster_mean_i = distance(sample, cluster_means[i]);\r\n        if (distance_to_cluster_mean_i < nearest_cluster_mean_distance) {\r\n          nearest_cluster_mean_distance = distance_to_cluster_mean_i;\r\n          nearest_cluster_mean_index = i;\r\n        }\r\n      }\r\n\r\n      if (\r\n        cluster_of_sample[sample_index] === -1 ||\r\n        cluster_of_sample[sample_index] !== nearest_cluster_mean_index\r\n      ) {\r\n        clusters_changed = true;\r\n      }\r\n\r\n      cluster_of_sample[sample_index] = nearest_cluster_mean_index;\r\n      cluster_size[nearest_cluster_mean_index] += 1;\r\n    });\r\n\r\n    // Recompute the means.\r\n    if (clusters_changed) {\r\n      cluster_means.forEach((mean) => mean.fill(0));\r\n      samples.forEach((sample, sample_index) => {\r\n        const sample_cluster_index = cluster_of_sample[sample_index];\r\n        const sample_cluster_size = cluster_size[sample_cluster_index];\r\n        const cluster_mean = cluster_means[sample_cluster_index];\r\n        cluster_mean.forEach(\r\n          (_, i) => (cluster_mean[i] += sample[i] / sample_cluster_size)\r\n        );\r\n      });\r\n    }\r\n  }\r\n\r\n  return cluster_means\r\n    .map((mean, index) => {\r\n      return {\r\n        mean,\r\n        size: cluster_size[index],\r\n      };\r\n    })\r\n    .filter((cluster) => cluster.size > 0);\r\n}\r\n"],"names":["$3cd1e6270ef4e68d$var$random_integer_in_range","min","max","Math","floor","random","window","addEventListener","file_input","document","getElementById","HTMLInputElement","$7ca515745310f523$var$on_selected_image_change","files","length","file","item","image","Image","src","URL","createObjectURL","color_elements","querySelectorAll","palette_size","sampling_cell_size","ceil","naturalWidth","naturalHeight","palette","canvas","createElement","width","height","context","getContext","Error","drawImage","$3cd1e6270ef4e68d$export$85a4233b636598d","image_data","samples_rgb","x_min","y_min","sample_index","x","y","sample_slice","data","slice","push","samples_hsl","map","color","r","g","b","h","s","l","span","clusters_initial_guess","i","random_index","samples","cluster_count","initial_guess","distance","cluster_means","JSON","parse","stringify","cluster_of_sample","Array","fill","cluster_size","clusters_changed","forEach","sample","nearest_cluster_mean_index","nearest_cluster_mean_distance","distance_to_cluster_mean_i","mean","sample_cluster_index","sample_cluster_size","cluster_mean","_","index","size","filter","cluster","a","sort","rgb_from_hue","p","q","t","getImageData","round","style","removeProperty","element","backgroundColor","setAttribute","click"],"version":3,"file":"index.021a97ed.js.map"}