{"mappings":"AAAA,SAASA,EAAMC,EAAeC,EAAaC,GACzC,OAAOF,EAAQC,EAAMA,EAAMD,EAAQE,EAAMA,EAAMF,EAGjD,MAAMG,EAGJC,MAAMH,EAAWC,GACf,OAAO,IAAIC,EAAKJ,EAAMM,KAAKC,EAAGL,EAAIK,EAAGJ,EAAII,GAAIP,EAAMM,KAAKE,EAAGN,EAAIM,EAAGL,EAAIK,IAGxEC,oBAAoBC,GAClB,OACGJ,KAAKC,EAAIG,EAAMH,IAAMD,KAAKC,EAAIG,EAAMH,IACpCD,KAAKE,EAAIE,EAAMF,IAAMF,KAAKE,EAAIE,EAAMF,GAIzCG,YACE,OAAOC,KAAKC,KAAKP,KAAKG,oBAAoB,IAAIL,EAAK,EAAG,KAGxDU,aACE,OAAO,IAAIV,EAAKE,KAAKC,EAAID,KAAKK,YAAaL,KAAKE,EAAIF,KAAKK,aAG3DI,KAAKL,GACH,OAAO,IAAIN,EAAKE,KAAKC,EAAIG,EAAMH,EAAGD,KAAKE,EAAIE,EAAMF,GAGnDQ,MAAMC,GACJ,OAAO,IAAIb,EAAKE,KAAKC,EAAIU,EAAQX,KAAKE,EAAIS,GA1B5CC,YAAmBX,EAAkBC,QAAlBD,EAAAA,OAAkBC,EAAAA,GA+ChC,SAASW,EAAeC,GAC7B,MAAO,CACLC,cAAe,IAAIjB,EAAK,EAAG,GAC3BkB,cAAe,IAAIlB,EAAK,EAAGgB,EAAQG,oBACnCC,gBAAiB,EACjBC,YAAa,KACVL,GAIA,SAASM,EACdC,EACAC,GAEA,GAAIC,EAAWF,GACb,OAAOA,EAGT,MAtEFG,YAuEIA,EAvEJC,sBAwEIA,EAxEJC,aAyEIA,EAzEJC,cA0EIA,EA1EJC,kBA2EIA,GACEP,EACJ,IAAIQ,EAAa,CACfC,SAAUT,EAAeN,cAAcN,KACrCY,EAAeL,cAAcN,MAAMY,IAErCS,SAAUV,EAAeL,eAgI7B,IACEgB,EACAF,EACAC,EAvGA,OA1BAF,EAAaI,EACXT,EACAC,EACAI,EAAWC,SACXD,EAAWE,SACXV,EAAeH,gBACf,EAAmC,GAA/BG,EAAeM,cACnBD,EACAC,GAEFE,EAAaI,EACXT,EACAC,EACAI,EAAWC,SACXD,EAAWE,SACXV,EAAeF,YACqB,GAA/BE,EAAeM,cAApB,EACAD,EACAC,GA6GFK,EA1GER,EA2GFM,EA1GED,EAAWC,SA2GbC,EA1GEF,EAAWE,SAHbF,EA+GIC,EAAS7B,EAAI+B,GAAS,EACjB,CACLF,SAAU,IAAIhC,GAAK,EAAKkC,EAAQF,EAAS5B,GACzC6B,SAAU,IAAIjC,GAAkB,EAAbiC,EAAS9B,EAAQ8B,EAAS7B,IAEtC4B,EAAS7B,EAAI+B,EAAS,EACxB,CACLF,SAAU,IAAIhC,EAAK,EAAIkC,EAAQF,EAAS5B,GACxC6B,SAAU,IAAIjC,GAAkB,EAAbiC,EAAS9B,EAAQ8B,EAAS7B,IAGxC,CAjOX4B,SAiOaA,EAjObC,SAiOuBA,GApHd,IACFV,EACHN,cAAec,EAAWC,SAC1Bd,cAAea,EAAWE,SAC1BZ,YACEE,EAAeF,YACfG,EACEY,EACEV,EACAC,EACAI,EAAWC,SACXD,EAAWE,SACXV,EAAeH,gBACfG,EAAeF,YACfO,EACAC,EACAC,IAKH,SAASL,EAAWY,GACzB,OAAyB,OAAlBC,EAAOD,GAGT,SAASC,EAAOD,GACrB,OAAOA,EAAMpB,cAAcb,EAAIiC,EAAMX,aAAc,EAC/C,SACAW,EAAMpB,cAAcb,EAAIiC,EAAMX,YAAc,EAC5C,KACA,KAQN,SAASS,EACPT,EACAa,EACAtB,EACAC,EACAsB,EACAC,EACAb,EACAC,GAEA,MAAMa,EAAcF,EAA0B,GAAfZ,EACzBe,EAAeH,EAA0B,GAAfZ,EAC1BgB,EAAgBH,EAA2B,GAAhBZ,EAC3BgB,EAAaJ,EAA2B,GAAhBZ,EAExBiB,EAAuB7B,EAAchB,MACzC,IAAID,EAAK0C,EAAaE,GACtB,IAAI5C,EAAK2C,EAAcE,IAMzB,KAHE5B,EAAcZ,oBAAoByC,GAClCpB,EAAcA,GAGd,MAAO,CAAEM,SAAUf,EAAegB,SAAUf,GAK9C,MACM6B,EACJ7B,EAAcd,EAAI,EACdyC,EAAanB,EAHQ,KAIrBkB,EAAgBlB,EAJK,KAMrBsB,EAAuB9B,EAAcR,aAC3CsC,EAAqB5C,IAAK,EAE1B,MAAM6C,EAAsBzC,KAAK0C,KAC9BjC,EAAcb,EAAI2C,GAAgBC,EAAqB5C,GAEpD+C,EAAoBlC,EAAcN,KACtCqC,EAAqBpC,MAAMqC,IAMvBG,GADgBD,EAAkBhD,EAAIqC,IACM,GAAMZ,GAClDyB,EACJ,GAAM7C,KAAK8C,GAAKF,EAA2Bb,EAM7C,MAAO,CACLP,SAAUmB,EACVlB,SAPwB,IAAIjC,EAC5BQ,KAAK+C,IAAIF,IACR7C,KAAKgD,KAAKtC,EAAcd,GAAKI,KAAKiD,IAAIJ,IACvCzC,MAAMM,EAAcX,cA4BxB,SAAS6B,EACPV,EACAC,EACAV,EACAC,EACAE,EACAC,EACAO,EACAC,EACA6B,GAEA,GAAIxC,EAAcd,GAAK,EACrB,OAAO,EAGT,MAAMuD,EAASnD,KAAKgD,KAAKtC,EAAcd,GACjCwD,EAAepD,KAAKgD,KAAKtC,EAAcf,GACvC0D,GAAiBD,EAEjBE,GACHtD,KAAK0C,IAAIS,EAAS1C,EAAcb,GAAKyB,EAAgBH,GACtDlB,KAAK0C,IAAIhC,EAAcd,GAEnB2D,EAAsBvD,KAAK0C,IAAIhC,EAAcf,EAAI2D,GACjDE,EACJxD,KAAK0C,IAAIU,EAAe3C,EAAcd,GAAKuB,EAE7C,IAAIuC,EACJ,GAAIF,EAAsBC,EACxBC,EAAchD,EAAcd,EAAIe,EAAcf,EAAI2D,MAC7C,CACL,MAAMI,EAAmB,EAAI,EAAIxC,EAI3ByC,GACHJ,EAAsBC,GAA0BE,EACnDD,EALwBzD,KAAK4D,OAC1BL,EAAsBC,GAA0BE,GAK/B,GAAK,EACnBN,EAAepD,KAAKgD,KAAKtC,EAAcf,GAAKgE,EAC5CN,EAAgBrD,KAAKgD,KAAKtC,EAAcf,GAAKgE,EAGrD,MAAME,GAAkB7D,KAAKgD,KAAKpC,IAAoB,EAAIM,GAQ1D,OAAOgC,GAHUO,EAD0B,GAAzCrE,EAH0BY,KAAK8D,MAAMD,EAAiBJ,GAAe,GAChBtC,GAErB,EAAI,GAAWC,EAEpBP,GC9J/BkD,OAAOC,iBAAiB,oBApExB,WACE,MAAMC,EAASC,SAASC,eAAe,eACvC,KAAMF,aAAkBG,mBACtB,MAAM,IAAIC,MAAM,sBAGlB,MAAMC,EAAiBL,EAAOM,WAAW,KAAM,CAAEC,OAAO,IACxD,GAAuB,OAAnBF,EACF,MAAM,IAAID,MAAM,sBAGlB,MAAMI,EAAe,CACnBvD,YAAa,IACbP,mBAAoB,IACpBQ,sBAAuB,GAAMnB,KAAK8C,GAClC1B,aAAc,GACdC,cAAe,IACfC,kBAAmB,GAEfoD,EAAiB,CACrBC,iBAAkB,QAClBC,iBAAkB,WAGpB,IAAIC,EAAatE,EAAekE,GAC5BK,EAAoC,KAExCb,EAAOD,iBAAiB,aAAce,IACpCA,EAAMC,iBACNH,EAAWjE,gBAAwBmE,EAAME,QAAUhB,EAAOiB,YAAe,EAA5C,KAE/BjB,EAAOD,iBAAiB,aAAce,IACpC,MAAMI,EAAQJ,EAAMK,QAAQC,KAAK,GACjC,GAAc,OAAVF,EACF,OAEFJ,EAAMC,iBACN,MAAMM,EAAcrB,EAAOsB,wBAC3BV,EAAWjE,iBACFuE,EAAMK,QAAUF,EAAYG,MAAQxB,EAAOiB,YAAe,EAAjE,KAGJ,MAAMQ,EAAe,KACnB,MAAMC,EAAqBC,YAAYC,MACjCC,EAAkBhB,GACnBa,EAAqBb,GAAsB,IAC5C,EACJA,EAAqBa,EACrBd,EAAa/D,EAAgB+D,EAAYiB,GAvF7C,SACEjB,EACAkB,EACAvF,GAEAuF,EAAQC,UAAYxF,EAAQmE,iBAC5BoB,EAAQE,SAAS,EAAG,EAAGF,EAAQ9B,OAAOiC,MAAOH,EAAQ9B,OAAOkC,QAE5DJ,EAAQK,OAERL,EAAQM,MAAMN,EAAQ9B,OAAOiC,MAAQ,EAAGH,EAAQ9B,OAAOkC,OAAS,GAChEJ,EAAQO,UAAU,EAAG,GAErBP,EAAQC,UAAYxF,EAAQoE,iBAC5BmB,EAAQQ,YACRR,EAAQS,KACN3B,EAAWjE,gBAA4C,GAA1BiE,EAAWzD,aACxC,EAAIyD,EAAWxD,cACfwD,EAAWzD,aACXyD,EAAWxD,eAEb0E,EAAQS,KACN3B,EAAWhE,YAAwC,GAA1BgE,EAAWzD,cACpC,EACAyD,EAAWzD,aACXyD,EAAWxD,eAEb0E,EAAQU,IACN5B,EAAWpE,cAAcd,EACzBkF,EAAWpE,cAAcb,EACzBiF,EAAW3D,YACX,EACA,EAAIlB,KAAK8C,IAEXiD,EAAQW,OAERX,EAAQY,UAoDNC,CAAgB/B,EAAYP,EAAgBI,GACxCzD,EAAW4D,IAEY,WAAvB/C,EAAO+C,IACPJ,EAAa9D,mBAAqB,IAElC8D,EAAa9D,oBAAsB,GACnC8D,EAAanD,mBAAqB,IAEpCuD,EAAatE,EAAekE,GAC5BK,EAAqB,KACrB+B,YAAW,IAAMC,sBAAsBpB,IAAe,MAEtDoB,sBAAsBpB,IAG1BA","sources":["projects/pong/pong.ts","projects/pong/demo.ts"],"sourcesContent":["function clamp(value: number, min: number, max: number): number {\r\n  return value < min ? min : value > max ? max : value;\r\n}\r\n\r\nclass Vec2 {\r\n  constructor(public x: number, public y: number) {}\r\n\r\n  clamp(min: Vec2, max: Vec2): Vec2 {\r\n    return new Vec2(clamp(this.x, min.x, max.x), clamp(this.y, min.y, max.y));\r\n  }\r\n\r\n  distance_squared_to(other: Vec2): number {\r\n    return (\r\n      (this.x - other.x) * (this.x - other.x) +\r\n      (this.y - other.y) * (this.y - other.y)\r\n    );\r\n  }\r\n\r\n  magnitude(): number {\r\n    return Math.sqrt(this.distance_squared_to(new Vec2(0, 0)));\r\n  }\r\n\r\n  normalized(): Vec2 {\r\n    return new Vec2(this.x / this.magnitude(), this.y / this.magnitude());\r\n  }\r\n\r\n  plus(other: Vec2): Vec2 {\r\n    return new Vec2(this.x + other.x, this.y + other.y);\r\n  }\r\n\r\n  times(scalar: number): Vec2 {\r\n    return new Vec2(this.x * scalar, this.y * scalar);\r\n  }\r\n}\r\n\r\nexport type GameOptions = {\r\n  ball_radius: number;\r\n  ball_initial_speed: number;\r\n  ball_max_bounce_angle: number;\r\n  paddle_width: number;\r\n  paddle_height: number;\r\n  ai_movement_speed: number;\r\n};\r\n\r\n// The table is a square with size 2 centered at (0, 0).\r\nexport type GameState = GameOptions & {\r\n  ball_position: Vec2;\r\n  ball_velocity: Vec2;\r\n  player_paddle_x: number;\r\n  ai_paddle_x: number;\r\n};\r\n\r\nexport function new_game_state(options: GameOptions): GameState {\r\n  return {\r\n    ball_position: new Vec2(0, 0),\r\n    ball_velocity: new Vec2(0, options.ball_initial_speed),\r\n    player_paddle_x: 0,\r\n    ai_paddle_x: 0,\r\n    ...options,\r\n  };\r\n}\r\n\r\nexport function next_game_state(\r\n  previous_state: GameState,\r\n  elapsed_time: number\r\n): GameState {\r\n  if (game_ended(previous_state)) {\r\n    return previous_state;\r\n  }\r\n\r\n  const {\r\n    ball_radius,\r\n    ball_max_bounce_angle,\r\n    paddle_width,\r\n    paddle_height,\r\n    ai_movement_speed,\r\n  } = previous_state;\r\n  let ball_state = {\r\n    position: previous_state.ball_position.plus(\r\n      previous_state.ball_velocity.times(elapsed_time)\r\n    ),\r\n    velocity: previous_state.ball_velocity,\r\n  };\r\n  ball_state = handle_ball_collision_with_paddle(\r\n    ball_radius,\r\n    ball_max_bounce_angle,\r\n    ball_state.position,\r\n    ball_state.velocity,\r\n    previous_state.player_paddle_x,\r\n    1 - previous_state.paddle_height * 0.5,\r\n    paddle_width,\r\n    paddle_height\r\n  );\r\n  ball_state = handle_ball_collision_with_paddle(\r\n    ball_radius,\r\n    ball_max_bounce_angle,\r\n    ball_state.position,\r\n    ball_state.velocity,\r\n    previous_state.ai_paddle_x,\r\n    -1 + previous_state.paddle_height * 0.5,\r\n    paddle_width,\r\n    paddle_height\r\n  );\r\n  ball_state = handle_ball_collision_with_walls(\r\n    ball_radius,\r\n    ball_state.position,\r\n    ball_state.velocity\r\n  );\r\n\r\n  return {\r\n    ...previous_state,\r\n    ball_position: ball_state.position,\r\n    ball_velocity: ball_state.velocity,\r\n    ai_paddle_x:\r\n      previous_state.ai_paddle_x +\r\n      elapsed_time *\r\n        ai_paddle_velocity(\r\n          ball_radius,\r\n          ball_max_bounce_angle,\r\n          ball_state.position,\r\n          ball_state.velocity,\r\n          previous_state.player_paddle_x,\r\n          previous_state.ai_paddle_x,\r\n          paddle_width,\r\n          paddle_height,\r\n          ai_movement_speed\r\n        ),\r\n  };\r\n}\r\n\r\nexport function game_ended(state: GameState): boolean {\r\n  return winner(state) !== null;\r\n}\r\n\r\nexport function winner(state: GameState): \"player\" | \"ai\" | null {\r\n  return state.ball_position.y - state.ball_radius < -1\r\n    ? \"player\"\r\n    : state.ball_position.y + state.ball_radius > 1\r\n    ? \"ai\"\r\n    : null;\r\n}\r\n\r\ntype BallState = {\r\n  position: Vec2;\r\n  velocity: Vec2;\r\n};\r\n\r\nfunction handle_ball_collision_with_paddle(\r\n  ball_radius: number,\r\n  ball_max_bounce_radians: number,\r\n  ball_position: Vec2,\r\n  ball_velocity: Vec2,\r\n  paddle_x: number,\r\n  paddle_y: number,\r\n  paddle_width: number,\r\n  paddle_height: number\r\n): BallState {\r\n  const paddle_left = paddle_x - paddle_width * 0.5;\r\n  const paddle_right = paddle_x + paddle_width * 0.5;\r\n  const paddle_bottom = paddle_y - paddle_height * 0.5;\r\n  const paddle_top = paddle_y + paddle_height * 0.5;\r\n\r\n  const nearest_paddle_point = ball_position.clamp(\r\n    new Vec2(paddle_left, paddle_bottom),\r\n    new Vec2(paddle_right, paddle_top)\r\n  );\r\n  const collides =\r\n    ball_position.distance_squared_to(nearest_paddle_point) <\r\n    ball_radius * ball_radius;\r\n\r\n  if (!collides) {\r\n    return { position: ball_position, velocity: ball_velocity };\r\n  }\r\n\r\n  // When there is a collision, separate the ball from the paddle.\r\n\r\n  const separation_padding = 0.001;\r\n  const separation_y =\r\n    ball_velocity.y < 0\r\n      ? paddle_top + ball_radius + separation_padding\r\n      : paddle_bottom - ball_radius - separation_padding;\r\n\r\n  const separation_direction = ball_velocity.normalized();\r\n  separation_direction.y *= -1;\r\n\r\n  const separation_distance = Math.abs(\r\n    (ball_position.y - separation_y) / separation_direction.y\r\n  );\r\n  const new_ball_position = ball_position.plus(\r\n    separation_direction.times(separation_distance)\r\n  );\r\n\r\n  // Once the ball is separated, calculate its new velocity after it bounces.\r\n\r\n  const center_offset = new_ball_position.x - paddle_x;\r\n  const center_offset_normalized = center_offset / (0.5 * paddle_width);\r\n  const bounce_angle =\r\n    0.5 * Math.PI - center_offset_normalized * ball_max_bounce_radians;\r\n  const new_ball_velocity = new Vec2(\r\n    Math.cos(bounce_angle),\r\n    -Math.sign(ball_velocity.y) * Math.sin(bounce_angle)\r\n  ).times(ball_velocity.magnitude());\r\n\r\n  return {\r\n    position: new_ball_position,\r\n    velocity: new_ball_velocity,\r\n  };\r\n}\r\n\r\nfunction handle_ball_collision_with_walls(\r\n  radius: number,\r\n  position: Vec2,\r\n  velocity: Vec2\r\n): BallState {\r\n  if (position.x - radius < -1) {\r\n    return {\r\n      position: new Vec2(-1 + radius, position.y),\r\n      velocity: new Vec2(velocity.x * -1, velocity.y),\r\n    };\r\n  } else if (position.x + radius > 1) {\r\n    return {\r\n      position: new Vec2(1 - radius, position.y),\r\n      velocity: new Vec2(velocity.x * -1, velocity.y),\r\n    };\r\n  } else {\r\n    return { position, velocity };\r\n  }\r\n}\r\n\r\nfunction ai_paddle_velocity(\r\n  ball_radius: number,\r\n  ball_max_bounce_angle: number,\r\n  ball_position: Vec2,\r\n  ball_velocity: Vec2,\r\n  player_paddle_x: number,\r\n  ai_paddle_x: number,\r\n  paddle_width: number,\r\n  paddle_height: number,\r\n  max_velocity: number\r\n): number {\r\n  if (ball_velocity.y >= 0) {\r\n    return 0;\r\n  }\r\n\r\n  const goal_y = Math.sign(ball_velocity.y);\r\n  const wall_ahead_x = Math.sign(ball_velocity.x);\r\n  const wall_behind_x = -wall_ahead_x;\r\n\r\n  const time_to_intercept =\r\n    (Math.abs(goal_y - ball_position.y) - paddle_height - ball_radius) /\r\n    Math.abs(ball_velocity.y);\r\n\r\n  const horizontal_movement = Math.abs(ball_velocity.x * time_to_intercept);\r\n  const distance_to_wall_ahead =\r\n    Math.abs(wall_ahead_x - ball_position.x) - ball_radius;\r\n\r\n  let intercept_x;\r\n  if (horizontal_movement < distance_to_wall_ahead) {\r\n    intercept_x = ball_position.x + ball_velocity.x * time_to_intercept;\r\n  } else {\r\n    const padded_edge_size = 2 - 2 * ball_radius;\r\n    const nr_wall_bounces = Math.floor(\r\n      (horizontal_movement - distance_to_wall_ahead) / padded_edge_size\r\n    );\r\n    const final_stretch_distance =\r\n      (horizontal_movement - distance_to_wall_ahead) % padded_edge_size;\r\n    intercept_x =\r\n      nr_wall_bounces % 2 == 0\r\n        ? wall_ahead_x - Math.sign(ball_velocity.x) * final_stretch_distance\r\n        : wall_behind_x + Math.sign(ball_velocity.x) * final_stretch_distance;\r\n  }\r\n\r\n  const target_serve_x = -Math.sign(player_paddle_x) * (1 - ball_radius);\r\n  const target_bounce_angle = Math.atan((target_serve_x - intercept_x) / 2);\r\n  const center_offset_normalized = target_bounce_angle / ball_max_bounce_angle;\r\n  const center_offset =\r\n    clamp(center_offset_normalized, -1, 1) * 0.5 * paddle_width;\r\n  const target_x = intercept_x - center_offset;\r\n  const target_dx = target_x - ai_paddle_x;\r\n\r\n  return max_velocity * target_dx;\r\n}\r\n","import {\r\n  GameState,\r\n  game_ended,\r\n  new_game_state,\r\n  next_game_state as next_game_state,\r\n  winner,\r\n} from \"./pong\";\r\n\r\ntype RenderOptions = {\r\n  background_color: string;\r\n  foreground_color: string;\r\n};\r\n\r\nfunction draw_game_state(\r\n  game_state: GameState,\r\n  context: CanvasRenderingContext2D,\r\n  options: RenderOptions\r\n) {\r\n  context.fillStyle = options.background_color;\r\n  context.fillRect(0, 0, context.canvas.width, context.canvas.height);\r\n\r\n  context.save();\r\n\r\n  context.scale(context.canvas.width / 2, context.canvas.height / 2);\r\n  context.translate(1, 1);\r\n\r\n  context.fillStyle = options.foreground_color;\r\n  context.beginPath();\r\n  context.rect(\r\n    game_state.player_paddle_x - game_state.paddle_width * 0.5,\r\n    1 - game_state.paddle_height,\r\n    game_state.paddle_width,\r\n    game_state.paddle_height\r\n  );\r\n  context.rect(\r\n    game_state.ai_paddle_x - game_state.paddle_width * 0.5,\r\n    -1,\r\n    game_state.paddle_width,\r\n    game_state.paddle_height\r\n  );\r\n  context.arc(\r\n    game_state.ball_position.x,\r\n    game_state.ball_position.y,\r\n    game_state.ball_radius,\r\n    0,\r\n    2 * Math.PI\r\n  );\r\n  context.fill();\r\n\r\n  context.restore();\r\n}\r\n\r\nfunction setup() {\r\n  const canvas = document.getElementById(\"demo-canvas\");\r\n  if (!(canvas instanceof HTMLCanvasElement)) {\r\n    throw new Error(\"cannot find canvas\");\r\n  }\r\n\r\n  const render_context = canvas.getContext(\"2d\", { alpha: false });\r\n  if (render_context === null) {\r\n    throw new Error(\"cannot get context\");\r\n  }\r\n\r\n  const game_options = {\r\n    ball_radius: 0.05,\r\n    ball_initial_speed: 1.6,\r\n    ball_max_bounce_angle: 0.3 * Math.PI,\r\n    paddle_width: 0.4,\r\n    paddle_height: 0.05,\r\n    ai_movement_speed: 1,\r\n  };\r\n  const render_options = {\r\n    background_color: \"white\",\r\n    foreground_color: \"#ed12a5\",\r\n  };\r\n\r\n  let game_state = new_game_state(game_options);\r\n  let last_frame_time_ms: number | null = null;\r\n\r\n  canvas.addEventListener(\"mousemove\", (event) => {\r\n    event.preventDefault();\r\n    game_state.player_paddle_x = -1 + (event.offsetX / canvas.clientWidth) * 2;\r\n  });\r\n  canvas.addEventListener(\"touchmove\", (event) => {\r\n    const touch = event.touches.item(0);\r\n    if (touch === null) {\r\n      return;\r\n    }\r\n    event.preventDefault();\r\n    const canvas_rect = canvas.getBoundingClientRect();\r\n    game_state.player_paddle_x =\r\n      -1 + ((touch.clientX - canvas_rect.left) / canvas.clientWidth) * 2;\r\n  });\r\n\r\n  const advance_game = () => {\r\n    const this_frame_time_ms = performance.now();\r\n    const elapsed_seconds = last_frame_time_ms\r\n      ? (this_frame_time_ms - last_frame_time_ms) / 1000\r\n      : 0;\r\n    last_frame_time_ms = this_frame_time_ms;\r\n    game_state = next_game_state(game_state, elapsed_seconds);\r\n    draw_game_state(game_state, render_context, render_options);\r\n    if (game_ended(game_state)) {\r\n      if (\r\n        winner(game_state) === \"player\" &&\r\n        game_options.ball_initial_speed < 3\r\n      ) {\r\n        game_options.ball_initial_speed += 0.2;\r\n        game_options.ai_movement_speed += 0.2;\r\n      }\r\n      game_state = new_game_state(game_options);\r\n      last_frame_time_ms = null;\r\n      setTimeout(() => requestAnimationFrame(advance_game), 1000);\r\n    } else {\r\n      requestAnimationFrame(advance_game);\r\n    }\r\n  };\r\n  advance_game();\r\n}\r\n\r\nwindow.addEventListener(\"DOMContentLoaded\", setup);\r\n"],"names":["$d61ed4d3afdadfea$var$clamp","value","min","max","$d61ed4d3afdadfea$var$Vec2","clamp","this","x","y","distance_squared_to","other","magnitude","Math","sqrt","normalized","plus","times","scalar","constructor","$d61ed4d3afdadfea$export$51479cab8e743335","options","ball_position","ball_velocity","ball_initial_speed","player_paddle_x","ai_paddle_x","$d61ed4d3afdadfea$export$4addf01929e3c8","previous_state","elapsed_time","$d61ed4d3afdadfea$export$88a01a05ddd76820","ball_radius","ball_max_bounce_angle","paddle_width","paddle_height","ai_movement_speed","ball_state","position","velocity","radius","$d61ed4d3afdadfea$var$handle_ball_collision_with_paddle","$d61ed4d3afdadfea$var$ai_paddle_velocity","state","$d61ed4d3afdadfea$export$b14ee659ac727b39","ball_max_bounce_radians","paddle_x","paddle_y","paddle_left","paddle_right","paddle_bottom","paddle_top","nearest_paddle_point","separation_y","separation_direction","separation_distance","abs","new_ball_position","center_offset_normalized","bounce_angle","PI","cos","sign","sin","max_velocity","goal_y","wall_ahead_x","wall_behind_x","time_to_intercept","horizontal_movement","distance_to_wall_ahead","intercept_x","padded_edge_size","final_stretch_distance","floor","target_serve_x","atan","window","addEventListener","canvas","document","getElementById","HTMLCanvasElement","Error","render_context","getContext","alpha","game_options","render_options","background_color","foreground_color","game_state","last_frame_time_ms","event","preventDefault","offsetX","clientWidth","touch","touches","item","canvas_rect","getBoundingClientRect","clientX","left","advance_game","this_frame_time_ms","performance","now","elapsed_seconds","context","fillStyle","fillRect","width","height","save","scale","translate","beginPath","rect","arc","fill","restore","$aa3362e99d164a68$var$draw_game_state","setTimeout","requestAnimationFrame"],"version":3,"file":"index.daf6678f.js.map"}