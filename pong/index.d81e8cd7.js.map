{"mappings":"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","sources":["<anon>","projects/pong/demo.ts","projects/pong/pong.ts"],"sourcesContent":["function $d61ed4d3afdadfea$var$clamp(value, min, max) {\n    return value < min ? min : value > max ? max : value;\n}\nclass $d61ed4d3afdadfea$var$Vec2 {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n    }\n    clamp(min, max) {\n        return new $d61ed4d3afdadfea$var$Vec2($d61ed4d3afdadfea$var$clamp(this.x, min.x, max.x), $d61ed4d3afdadfea$var$clamp(this.y, min.y, max.y));\n    }\n    distance_squared_to(other) {\n        return (this.x - other.x) * (this.x - other.x) + (this.y - other.y) * (this.y - other.y);\n    }\n    magnitude() {\n        return Math.sqrt(this.distance_squared_to(new $d61ed4d3afdadfea$var$Vec2(0, 0)));\n    }\n    normalized() {\n        return new $d61ed4d3afdadfea$var$Vec2(this.x / this.magnitude(), this.y / this.magnitude());\n    }\n    plus(other) {\n        return new $d61ed4d3afdadfea$var$Vec2(this.x + other.x, this.y + other.y);\n    }\n    times(scalar) {\n        return new $d61ed4d3afdadfea$var$Vec2(this.x * scalar, this.y * scalar);\n    }\n}\nfunction $d61ed4d3afdadfea$export$51479cab8e743335(options) {\n    return {\n        ball_position: new $d61ed4d3afdadfea$var$Vec2(0, 0),\n        ball_velocity: new $d61ed4d3afdadfea$var$Vec2(0, options.ball_initial_speed),\n        player_paddle_x: 0,\n        ai_paddle_x: 0,\n        ...options\n    };\n}\nfunction $d61ed4d3afdadfea$export$4addf01929e3c8(previous_state, elapsed_time) {\n    if ($d61ed4d3afdadfea$export$88a01a05ddd76820(previous_state)) return previous_state;\n    const { ball_radius: ball_radius, ball_max_bounce_angle: ball_max_bounce_angle, paddle_width: paddle_width, paddle_height: paddle_height, ai_movement_speed: ai_movement_speed } = previous_state;\n    let ball_state = {\n        position: previous_state.ball_position.plus(previous_state.ball_velocity.times(elapsed_time)),\n        velocity: previous_state.ball_velocity\n    };\n    ball_state = $d61ed4d3afdadfea$var$handle_ball_collision_with_paddle(ball_radius, ball_max_bounce_angle, ball_state.position, ball_state.velocity, previous_state.player_paddle_x, 1 - previous_state.paddle_height * 0.5, paddle_width, paddle_height);\n    ball_state = $d61ed4d3afdadfea$var$handle_ball_collision_with_paddle(ball_radius, ball_max_bounce_angle, ball_state.position, ball_state.velocity, previous_state.ai_paddle_x, -1 + previous_state.paddle_height * 0.5, paddle_width, paddle_height);\n    ball_state = $d61ed4d3afdadfea$var$handle_ball_collision_with_walls(ball_radius, ball_state.position, ball_state.velocity);\n    return {\n        ...previous_state,\n        ball_position: ball_state.position,\n        ball_velocity: ball_state.velocity,\n        ai_paddle_x: previous_state.ai_paddle_x + elapsed_time * $d61ed4d3afdadfea$var$ai_paddle_velocity(ball_radius, ball_max_bounce_angle, ball_state.position, ball_state.velocity, previous_state.player_paddle_x, previous_state.ai_paddle_x, paddle_width, paddle_height, ai_movement_speed)\n    };\n}\nfunction $d61ed4d3afdadfea$export$88a01a05ddd76820(state) {\n    return $d61ed4d3afdadfea$export$b14ee659ac727b39(state) !== null;\n}\nfunction $d61ed4d3afdadfea$export$b14ee659ac727b39(state) {\n    return state.ball_position.y - state.ball_radius < -1 ? \"player\" : state.ball_position.y + state.ball_radius > 1 ? \"ai\" : null;\n}\nfunction $d61ed4d3afdadfea$var$handle_ball_collision_with_paddle(ball_radius, ball_max_bounce_radians, ball_position, ball_velocity, paddle_x, paddle_y, paddle_width, paddle_height) {\n    const paddle_left = paddle_x - paddle_width * 0.5;\n    const paddle_right = paddle_x + paddle_width * 0.5;\n    const paddle_bottom = paddle_y - paddle_height * 0.5;\n    const paddle_top = paddle_y + paddle_height * 0.5;\n    const nearest_paddle_point = ball_position.clamp(new $d61ed4d3afdadfea$var$Vec2(paddle_left, paddle_bottom), new $d61ed4d3afdadfea$var$Vec2(paddle_right, paddle_top));\n    const collides = ball_position.distance_squared_to(nearest_paddle_point) < ball_radius * ball_radius;\n    if (!collides) return {\n        position: ball_position,\n        velocity: ball_velocity\n    };\n    // When there is a collision, separate the ball from the paddle.\n    const separation_padding = 0.001;\n    const separation_y = ball_velocity.y < 0 ? paddle_top + ball_radius + separation_padding : paddle_bottom - ball_radius - separation_padding;\n    const separation_direction = ball_velocity.normalized();\n    separation_direction.y *= -1;\n    const separation_distance = Math.abs((ball_position.y - separation_y) / separation_direction.y);\n    const new_ball_position = ball_position.plus(separation_direction.times(separation_distance));\n    // Once the ball is separated, calculate its new velocity after it bounces.\n    const center_offset = new_ball_position.x - paddle_x;\n    const center_offset_normalized = center_offset / (0.5 * paddle_width);\n    const bounce_angle = 0.5 * Math.PI - center_offset_normalized * ball_max_bounce_radians;\n    const new_ball_velocity = new $d61ed4d3afdadfea$var$Vec2(Math.cos(bounce_angle), -Math.sign(ball_velocity.y) * Math.sin(bounce_angle)).times(ball_velocity.magnitude());\n    return {\n        position: new_ball_position,\n        velocity: new_ball_velocity\n    };\n}\nfunction $d61ed4d3afdadfea$var$handle_ball_collision_with_walls(radius, position, velocity) {\n    if (position.x - radius < -1) return {\n        position: new $d61ed4d3afdadfea$var$Vec2(-1 + radius, position.y),\n        velocity: new $d61ed4d3afdadfea$var$Vec2(velocity.x * -1, velocity.y)\n    };\n    else if (position.x + radius > 1) return {\n        position: new $d61ed4d3afdadfea$var$Vec2(1 - radius, position.y),\n        velocity: new $d61ed4d3afdadfea$var$Vec2(velocity.x * -1, velocity.y)\n    };\n    else return {\n        position: position,\n        velocity: velocity\n    };\n}\nfunction $d61ed4d3afdadfea$var$ai_paddle_velocity(ball_radius, ball_max_bounce_angle, ball_position, ball_velocity, player_paddle_x, ai_paddle_x, paddle_width, paddle_height, max_velocity) {\n    if (ball_velocity.y >= 0) return 0;\n    const goal_y = Math.sign(ball_velocity.y);\n    const wall_ahead_x = Math.sign(ball_velocity.x);\n    const wall_behind_x = -wall_ahead_x;\n    const time_to_intercept = (Math.abs(goal_y - ball_position.y) - paddle_height - ball_radius) / Math.abs(ball_velocity.y);\n    const horizontal_movement = Math.abs(ball_velocity.x * time_to_intercept);\n    const distance_to_wall_ahead = Math.abs(wall_ahead_x - ball_position.x) - ball_radius;\n    let intercept_x;\n    if (horizontal_movement < distance_to_wall_ahead) intercept_x = ball_position.x + ball_velocity.x * time_to_intercept;\n    else {\n        const padded_edge_size = 2 - 2 * ball_radius;\n        const nr_wall_bounces = Math.floor((horizontal_movement - distance_to_wall_ahead) / padded_edge_size);\n        const final_stretch_distance = (horizontal_movement - distance_to_wall_ahead) % padded_edge_size;\n        intercept_x = nr_wall_bounces % 2 == 0 ? wall_ahead_x - Math.sign(ball_velocity.x) * final_stretch_distance : wall_behind_x + Math.sign(ball_velocity.x) * final_stretch_distance;\n    }\n    const target_serve_x = -Math.sign(player_paddle_x) * (1 - ball_radius);\n    const target_bounce_angle = Math.atan((target_serve_x - intercept_x) / 2);\n    const center_offset_normalized = target_bounce_angle / ball_max_bounce_angle;\n    const center_offset = $d61ed4d3afdadfea$var$clamp(center_offset_normalized, -1, 1) * 0.5 * paddle_width;\n    const target_x = intercept_x - center_offset;\n    const target_dx = target_x - ai_paddle_x;\n    return max_velocity * target_dx;\n}\n\n\nfunction $aa3362e99d164a68$var$draw_game_state(game_state, context, options) {\n    context.fillStyle = options.background_color;\n    context.fillRect(0, 0, context.canvas.width, context.canvas.height);\n    context.save();\n    context.scale(context.canvas.width / 2, context.canvas.height / 2);\n    context.translate(1, 1);\n    context.fillStyle = options.foreground_color;\n    context.beginPath();\n    context.rect(game_state.player_paddle_x - game_state.paddle_width * 0.5, 1 - game_state.paddle_height, game_state.paddle_width, game_state.paddle_height);\n    context.rect(game_state.ai_paddle_x - game_state.paddle_width * 0.5, -1, game_state.paddle_width, game_state.paddle_height);\n    context.arc(game_state.ball_position.x, game_state.ball_position.y, game_state.ball_radius, 0, 2 * Math.PI);\n    context.fill();\n    context.restore();\n}\nfunction $aa3362e99d164a68$var$setup() {\n    const canvas = document.getElementById(\"demo-canvas\");\n    if (!(canvas instanceof HTMLCanvasElement)) throw new Error(\"cannot find canvas\");\n    const render_context = canvas.getContext(\"2d\", {\n        alpha: false\n    });\n    if (render_context === null) throw new Error(\"cannot get context\");\n    const game_options = {\n        ball_radius: 0.05,\n        ball_initial_speed: 1.6,\n        ball_max_bounce_angle: 0.3 * Math.PI,\n        paddle_width: 0.4,\n        paddle_height: 0.05,\n        ai_movement_speed: 1\n    };\n    const render_options = {\n        background_color: \"white\",\n        foreground_color: \"#ed12a5\"\n    };\n    let game_state = (0, $d61ed4d3afdadfea$export$51479cab8e743335)(game_options);\n    let last_frame_time_ms = null;\n    canvas.addEventListener(\"mousemove\", (event)=>{\n        event.preventDefault();\n        game_state.player_paddle_x = -1 + event.offsetX / canvas.clientWidth * 2;\n    });\n    canvas.addEventListener(\"touchmove\", (event)=>{\n        const touch = event.touches.item(0);\n        if (touch === null) return;\n        event.preventDefault();\n        const canvas_rect = canvas.getBoundingClientRect();\n        game_state.player_paddle_x = -1 + (touch.clientX - canvas_rect.left) / canvas.clientWidth * 2;\n    });\n    const advance_game = ()=>{\n        const this_frame_time_ms = performance.now();\n        const elapsed_seconds = last_frame_time_ms ? (this_frame_time_ms - last_frame_time_ms) / 1000 : 0;\n        last_frame_time_ms = this_frame_time_ms;\n        game_state = (0, $d61ed4d3afdadfea$export$4addf01929e3c8)(game_state, elapsed_seconds);\n        $aa3362e99d164a68$var$draw_game_state(game_state, render_context, render_options);\n        if ((0, $d61ed4d3afdadfea$export$88a01a05ddd76820)(game_state)) {\n            if ((0, $d61ed4d3afdadfea$export$b14ee659ac727b39)(game_state) === \"player\" && game_options.ball_initial_speed < 3) {\n                game_options.ball_initial_speed += 0.2;\n                game_options.ai_movement_speed += 0.2;\n            }\n            game_state = (0, $d61ed4d3afdadfea$export$51479cab8e743335)(game_options);\n            last_frame_time_ms = null;\n            setTimeout(()=>requestAnimationFrame(advance_game), 1000);\n        } else requestAnimationFrame(advance_game);\n    };\n    advance_game();\n}\nwindow.addEventListener(\"DOMContentLoaded\", $aa3362e99d164a68$var$setup);\n\n\n//# sourceMappingURL=index.d81e8cd7.js.map\n","import {\r\n  GameState,\r\n  game_ended,\r\n  new_game_state,\r\n  next_game_state as next_game_state,\r\n  winner,\r\n} from \"./pong\";\r\n\r\ntype RenderOptions = {\r\n  background_color: string;\r\n  foreground_color: string;\r\n};\r\n\r\nfunction draw_game_state(\r\n  game_state: GameState,\r\n  context: CanvasRenderingContext2D,\r\n  options: RenderOptions\r\n) {\r\n  context.fillStyle = options.background_color;\r\n  context.fillRect(0, 0, context.canvas.width, context.canvas.height);\r\n\r\n  context.save();\r\n\r\n  context.scale(context.canvas.width / 2, context.canvas.height / 2);\r\n  context.translate(1, 1);\r\n\r\n  context.fillStyle = options.foreground_color;\r\n  context.beginPath();\r\n  context.rect(\r\n    game_state.player_paddle_x - game_state.paddle_width * 0.5,\r\n    1 - game_state.paddle_height,\r\n    game_state.paddle_width,\r\n    game_state.paddle_height\r\n  );\r\n  context.rect(\r\n    game_state.ai_paddle_x - game_state.paddle_width * 0.5,\r\n    -1,\r\n    game_state.paddle_width,\r\n    game_state.paddle_height\r\n  );\r\n  context.arc(\r\n    game_state.ball_position.x,\r\n    game_state.ball_position.y,\r\n    game_state.ball_radius,\r\n    0,\r\n    2 * Math.PI\r\n  );\r\n  context.fill();\r\n\r\n  context.restore();\r\n}\r\n\r\nfunction setup() {\r\n  const canvas = document.getElementById(\"demo-canvas\");\r\n  if (!(canvas instanceof HTMLCanvasElement)) {\r\n    throw new Error(\"cannot find canvas\");\r\n  }\r\n\r\n  const render_context = canvas.getContext(\"2d\", { alpha: false });\r\n  if (render_context === null) {\r\n    throw new Error(\"cannot get context\");\r\n  }\r\n\r\n  const game_options = {\r\n    ball_radius: 0.05,\r\n    ball_initial_speed: 1.6,\r\n    ball_max_bounce_angle: 0.3 * Math.PI,\r\n    paddle_width: 0.4,\r\n    paddle_height: 0.05,\r\n    ai_movement_speed: 1,\r\n  };\r\n  const render_options = {\r\n    background_color: \"white\",\r\n    foreground_color: \"#ed12a5\",\r\n  };\r\n\r\n  let game_state = new_game_state(game_options);\r\n  let last_frame_time_ms: number | null = null;\r\n\r\n  canvas.addEventListener(\"mousemove\", (event) => {\r\n    event.preventDefault();\r\n    game_state.player_paddle_x = -1 + (event.offsetX / canvas.clientWidth) * 2;\r\n  });\r\n  canvas.addEventListener(\"touchmove\", (event) => {\r\n    const touch = event.touches.item(0);\r\n    if (touch === null) {\r\n      return;\r\n    }\r\n    event.preventDefault();\r\n    const canvas_rect = canvas.getBoundingClientRect();\r\n    game_state.player_paddle_x =\r\n      -1 + ((touch.clientX - canvas_rect.left) / canvas.clientWidth) * 2;\r\n  });\r\n\r\n  const advance_game = () => {\r\n    const this_frame_time_ms = performance.now();\r\n    const elapsed_seconds = last_frame_time_ms\r\n      ? (this_frame_time_ms - last_frame_time_ms) / 1000\r\n      : 0;\r\n    last_frame_time_ms = this_frame_time_ms;\r\n    game_state = next_game_state(game_state, elapsed_seconds);\r\n    draw_game_state(game_state, render_context, render_options);\r\n    if (game_ended(game_state)) {\r\n      if (\r\n        winner(game_state) === \"player\" &&\r\n        game_options.ball_initial_speed < 3\r\n      ) {\r\n        game_options.ball_initial_speed += 0.2;\r\n        game_options.ai_movement_speed += 0.2;\r\n      }\r\n      game_state = new_game_state(game_options);\r\n      last_frame_time_ms = null;\r\n      setTimeout(() => requestAnimationFrame(advance_game), 1000);\r\n    } else {\r\n      requestAnimationFrame(advance_game);\r\n    }\r\n  };\r\n  advance_game();\r\n}\r\n\r\nwindow.addEventListener(\"DOMContentLoaded\", setup);\r\n","function clamp(value: number, min: number, max: number): number {\r\n  return value < min ? min : value > max ? max : value;\r\n}\r\n\r\nclass Vec2 {\r\n  constructor(public x: number, public y: number) {}\r\n\r\n  clamp(min: Vec2, max: Vec2): Vec2 {\r\n    return new Vec2(clamp(this.x, min.x, max.x), clamp(this.y, min.y, max.y));\r\n  }\r\n\r\n  distance_squared_to(other: Vec2): number {\r\n    return (\r\n      (this.x - other.x) * (this.x - other.x) +\r\n      (this.y - other.y) * (this.y - other.y)\r\n    );\r\n  }\r\n\r\n  magnitude(): number {\r\n    return Math.sqrt(this.distance_squared_to(new Vec2(0, 0)));\r\n  }\r\n\r\n  normalized(): Vec2 {\r\n    return new Vec2(this.x / this.magnitude(), this.y / this.magnitude());\r\n  }\r\n\r\n  plus(other: Vec2): Vec2 {\r\n    return new Vec2(this.x + other.x, this.y + other.y);\r\n  }\r\n\r\n  times(scalar: number): Vec2 {\r\n    return new Vec2(this.x * scalar, this.y * scalar);\r\n  }\r\n}\r\n\r\nexport type GameOptions = {\r\n  ball_radius: number;\r\n  ball_initial_speed: number;\r\n  ball_max_bounce_angle: number;\r\n  paddle_width: number;\r\n  paddle_height: number;\r\n  ai_movement_speed: number;\r\n};\r\n\r\n// The table is a square with size 2 centered at (0, 0).\r\nexport type GameState = GameOptions & {\r\n  ball_position: Vec2;\r\n  ball_velocity: Vec2;\r\n  player_paddle_x: number;\r\n  ai_paddle_x: number;\r\n};\r\n\r\nexport function new_game_state(options: GameOptions): GameState {\r\n  return {\r\n    ball_position: new Vec2(0, 0),\r\n    ball_velocity: new Vec2(0, options.ball_initial_speed),\r\n    player_paddle_x: 0,\r\n    ai_paddle_x: 0,\r\n    ...options,\r\n  };\r\n}\r\n\r\nexport function next_game_state(\r\n  previous_state: GameState,\r\n  elapsed_time: number\r\n): GameState {\r\n  if (game_ended(previous_state)) {\r\n    return previous_state;\r\n  }\r\n\r\n  const {\r\n    ball_radius,\r\n    ball_max_bounce_angle,\r\n    paddle_width,\r\n    paddle_height,\r\n    ai_movement_speed,\r\n  } = previous_state;\r\n  let ball_state = {\r\n    position: previous_state.ball_position.plus(\r\n      previous_state.ball_velocity.times(elapsed_time)\r\n    ),\r\n    velocity: previous_state.ball_velocity,\r\n  };\r\n  ball_state = handle_ball_collision_with_paddle(\r\n    ball_radius,\r\n    ball_max_bounce_angle,\r\n    ball_state.position,\r\n    ball_state.velocity,\r\n    previous_state.player_paddle_x,\r\n    1 - previous_state.paddle_height * 0.5,\r\n    paddle_width,\r\n    paddle_height\r\n  );\r\n  ball_state = handle_ball_collision_with_paddle(\r\n    ball_radius,\r\n    ball_max_bounce_angle,\r\n    ball_state.position,\r\n    ball_state.velocity,\r\n    previous_state.ai_paddle_x,\r\n    -1 + previous_state.paddle_height * 0.5,\r\n    paddle_width,\r\n    paddle_height\r\n  );\r\n  ball_state = handle_ball_collision_with_walls(\r\n    ball_radius,\r\n    ball_state.position,\r\n    ball_state.velocity\r\n  );\r\n\r\n  return {\r\n    ...previous_state,\r\n    ball_position: ball_state.position,\r\n    ball_velocity: ball_state.velocity,\r\n    ai_paddle_x:\r\n      previous_state.ai_paddle_x +\r\n      elapsed_time *\r\n        ai_paddle_velocity(\r\n          ball_radius,\r\n          ball_max_bounce_angle,\r\n          ball_state.position,\r\n          ball_state.velocity,\r\n          previous_state.player_paddle_x,\r\n          previous_state.ai_paddle_x,\r\n          paddle_width,\r\n          paddle_height,\r\n          ai_movement_speed\r\n        ),\r\n  };\r\n}\r\n\r\nexport function game_ended(state: GameState): boolean {\r\n  return winner(state) !== null;\r\n}\r\n\r\nexport function winner(state: GameState): \"player\" | \"ai\" | null {\r\n  return state.ball_position.y - state.ball_radius < -1\r\n    ? \"player\"\r\n    : state.ball_position.y + state.ball_radius > 1\r\n    ? \"ai\"\r\n    : null;\r\n}\r\n\r\ntype BallState = {\r\n  position: Vec2;\r\n  velocity: Vec2;\r\n};\r\n\r\nfunction handle_ball_collision_with_paddle(\r\n  ball_radius: number,\r\n  ball_max_bounce_radians: number,\r\n  ball_position: Vec2,\r\n  ball_velocity: Vec2,\r\n  paddle_x: number,\r\n  paddle_y: number,\r\n  paddle_width: number,\r\n  paddle_height: number\r\n): BallState {\r\n  const paddle_left = paddle_x - paddle_width * 0.5;\r\n  const paddle_right = paddle_x + paddle_width * 0.5;\r\n  const paddle_bottom = paddle_y - paddle_height * 0.5;\r\n  const paddle_top = paddle_y + paddle_height * 0.5;\r\n\r\n  const nearest_paddle_point = ball_position.clamp(\r\n    new Vec2(paddle_left, paddle_bottom),\r\n    new Vec2(paddle_right, paddle_top)\r\n  );\r\n  const collides =\r\n    ball_position.distance_squared_to(nearest_paddle_point) <\r\n    ball_radius * ball_radius;\r\n\r\n  if (!collides) {\r\n    return { position: ball_position, velocity: ball_velocity };\r\n  }\r\n\r\n  // When there is a collision, separate the ball from the paddle.\r\n\r\n  const separation_padding = 0.001;\r\n  const separation_y =\r\n    ball_velocity.y < 0\r\n      ? paddle_top + ball_radius + separation_padding\r\n      : paddle_bottom - ball_radius - separation_padding;\r\n\r\n  const separation_direction = ball_velocity.normalized();\r\n  separation_direction.y *= -1;\r\n\r\n  const separation_distance = Math.abs(\r\n    (ball_position.y - separation_y) / separation_direction.y\r\n  );\r\n  const new_ball_position = ball_position.plus(\r\n    separation_direction.times(separation_distance)\r\n  );\r\n\r\n  // Once the ball is separated, calculate its new velocity after it bounces.\r\n\r\n  const center_offset = new_ball_position.x - paddle_x;\r\n  const center_offset_normalized = center_offset / (0.5 * paddle_width);\r\n  const bounce_angle =\r\n    0.5 * Math.PI - center_offset_normalized * ball_max_bounce_radians;\r\n  const new_ball_velocity = new Vec2(\r\n    Math.cos(bounce_angle),\r\n    -Math.sign(ball_velocity.y) * Math.sin(bounce_angle)\r\n  ).times(ball_velocity.magnitude());\r\n\r\n  return {\r\n    position: new_ball_position,\r\n    velocity: new_ball_velocity,\r\n  };\r\n}\r\n\r\nfunction handle_ball_collision_with_walls(\r\n  radius: number,\r\n  position: Vec2,\r\n  velocity: Vec2\r\n): BallState {\r\n  if (position.x - radius < -1) {\r\n    return {\r\n      position: new Vec2(-1 + radius, position.y),\r\n      velocity: new Vec2(velocity.x * -1, velocity.y),\r\n    };\r\n  } else if (position.x + radius > 1) {\r\n    return {\r\n      position: new Vec2(1 - radius, position.y),\r\n      velocity: new Vec2(velocity.x * -1, velocity.y),\r\n    };\r\n  } else {\r\n    return { position, velocity };\r\n  }\r\n}\r\n\r\nfunction ai_paddle_velocity(\r\n  ball_radius: number,\r\n  ball_max_bounce_angle: number,\r\n  ball_position: Vec2,\r\n  ball_velocity: Vec2,\r\n  player_paddle_x: number,\r\n  ai_paddle_x: number,\r\n  paddle_width: number,\r\n  paddle_height: number,\r\n  max_velocity: number\r\n): number {\r\n  if (ball_velocity.y >= 0) {\r\n    return 0;\r\n  }\r\n\r\n  const goal_y = Math.sign(ball_velocity.y);\r\n  const wall_ahead_x = Math.sign(ball_velocity.x);\r\n  const wall_behind_x = -wall_ahead_x;\r\n\r\n  const time_to_intercept =\r\n    (Math.abs(goal_y - ball_position.y) - paddle_height - ball_radius) /\r\n    Math.abs(ball_velocity.y);\r\n\r\n  const horizontal_movement = Math.abs(ball_velocity.x * time_to_intercept);\r\n  const distance_to_wall_ahead =\r\n    Math.abs(wall_ahead_x - ball_position.x) - ball_radius;\r\n\r\n  let intercept_x;\r\n  if (horizontal_movement < distance_to_wall_ahead) {\r\n    intercept_x = ball_position.x + ball_velocity.x * time_to_intercept;\r\n  } else {\r\n    const padded_edge_size = 2 - 2 * ball_radius;\r\n    const nr_wall_bounces = Math.floor(\r\n      (horizontal_movement - distance_to_wall_ahead) / padded_edge_size\r\n    );\r\n    const final_stretch_distance =\r\n      (horizontal_movement - distance_to_wall_ahead) % padded_edge_size;\r\n    intercept_x =\r\n      nr_wall_bounces % 2 == 0\r\n        ? wall_ahead_x - Math.sign(ball_velocity.x) * final_stretch_distance\r\n        : wall_behind_x + Math.sign(ball_velocity.x) * final_stretch_distance;\r\n  }\r\n\r\n  const target_serve_x = -Math.sign(player_paddle_x) * (1 - ball_radius);\r\n  const target_bounce_angle = Math.atan((target_serve_x - intercept_x) / 2);\r\n  const center_offset_normalized = target_bounce_angle / ball_max_bounce_angle;\r\n  const center_offset =\r\n    clamp(center_offset_normalized, -1, 1) * 0.5 * paddle_width;\r\n  const target_x = intercept_x - center_offset;\r\n  const target_dx = target_x - ai_paddle_x;\r\n\r\n  return max_velocity * target_dx;\r\n}\r\n"],"names":["$d61ed4d3afdadfea$var$clamp","value","min","max","$d61ed4d3afdadfea$var$Vec2","constructor","x","y","clamp","distance_squared_to","other","magnitude","Math","sqrt","normalized","plus","times","scalar","$d61ed4d3afdadfea$export$51479cab8e743335","options","ball_position","ball_velocity","ball_initial_speed","player_paddle_x","ai_paddle_x","$d61ed4d3afdadfea$export$b14ee659ac727b39","state","ball_radius","$d61ed4d3afdadfea$var$handle_ball_collision_with_paddle","ball_max_bounce_radians","paddle_x","paddle_y","paddle_width","paddle_height","paddle_bottom","paddle_top","nearest_paddle_point","position","velocity","separation_y","separation_direction","separation_distance","abs","new_ball_position","bounce_angle","PI","center_offset_normalized","cos","sign","sin","window","addEventListener","canvas","document","getElementById","HTMLCanvasElement","Error","render_context","getContext","alpha","game_options","ball_max_bounce_angle","ai_movement_speed","game_state","last_frame_time_ms","event","preventDefault","offsetX","clientWidth","touch","touches","item","canvas_rect","getBoundingClientRect","clientX","left","advance_game","this_frame_time_ms","performance","now","elapsed_seconds","previous_state","elapsed_time","ball_state","$d61ed4d3afdadfea$var$ai_paddle_velocity","max_velocity","intercept_x","goal_y","wall_ahead_x","time_to_intercept","horizontal_movement","distance_to_wall_ahead","padded_edge_size","nr_wall_bounces","floor","final_stretch_distance","wall_behind_x","target_bounce_angle","atan","target_serve_x","target_x","context","fillStyle","fillRect","width","height","save","scale","translate","beginPath","rect","arc","fill","restore","setTimeout","requestAnimationFrame"],"version":3,"file":"index.d81e8cd7.js.map"}